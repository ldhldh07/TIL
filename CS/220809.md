#### 배열

- 배열은 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복을 허용하고 순서가 있다.
- 탐색에 `O(1)`
- 삽입과 삭제 `O(n)`이 걸림
- 데이터 추가와 삭제를 많이 하는 것은 연결 리스트, 탐색을 많이 하는 것은 배열로 하는 것이 좋다
- 인덱스에 해당하는 원소를 빠르게 접근해야 하거나 간단하게 데이터를 쌓고 싶을 때 사용합니다.



##### 랜던 접근과 순차적 접근

- `랜덤 접근` : 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- `순차적 접근` : 데이터를 저장된 순서대로 검색해야 함
- 랜덤 접근은 직접 접근이라고도 한다.

##### 배열과 연결 리스트 비교

- `배열`
  - 상자를 순서대로 나열한 데이터 구조
  - 몇 번째 상자인지만 알면 해당 상자의 요소를 끄집어낼 수 있습니다.
  - 랜덤 접근이 가능하다. O(1)

- `연결리스트`

  - 상자를 선으로 연결한 형태의 데이터 구조
  - 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 한다.

  - 랜덤 접근이 불가능하다 O(n)

- 탐색은 배열이 빠르고 연결리스트는 느리다

  - 배열은 상자 위에 있는 요소를 탐색하면 되는 반면, 연결리스트는 상자를 열어야 하고 주어진 선을 기반으로 순차적으로 열어야 한다.

- 데이터 추가 및 삭제는 연결 리스트가 더 빠르고 배열은 느리가.

  - 배열은 모든 상자를 앞으로 옮겨야 추가가 가능하지만, 연결 리스트는 선을 바꿔서 연결해주기만 하면 된다.

#### 벡터

- 동적으로 요소를 할당할 수 있는 동적 배열
- 컴파일 시점에 계수를 모를 때 사용
- 중복을 허용하고 순서가 있고 랜덤 접근이 가능
- 탐색, 맨 뒤의 요소 삭제, 삽입 : O(1)
- 맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입하는데 O(n)
- push back()의 경우 O(1)의 시간이 걸린다, 벡터의 크기가 증가되는 시간 복잡도가 amortized 복잡도, 즉 상수 시간 복잡도 O(1)과 유사한 시간 복잡도를 가짐
  - 매번 크기가 증가하는 것이 아니라 2의 제곱승 + 1마다 크기를 2배로 늘린다.
- 평균적으로 드는 비용이 3이고 이는 1이라는 상수 시간보다는 크지만 상수 시간에 가까운 amortized 복잡도를 가진다는 것을 알 수 있다. 그래서 O(1)
- `push_back()` : 뒤부터 요소를 더함
- `pop_back()` : 맨 뒤부터 지움
- `erase()` : 지움
- `find()`: 요소를 찾음
- `clear()`: 배열을 초기화함



#### 스택

- 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO, Last In First Out)을 가진 자료 구조입니다. 
- 재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 쓰입니다. 
- 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸립니다.

#### 큐

- 먼저 집어넣은 데이터가 먼저 나오는 성질 (FIFO, first In First Out)을 지닌 자료 구조
-  삽입 및 삭제에 O(1), 탐색에 O(n)이 걸립니다.

- CPU 작업을 기다리는 프로세스, 스레드 행렬, 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용



### 비선형 자료 구조

- 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조

#### 그래프

- 정점과 간선으로 이루어진 자료 구조를 말한다.

- `정점` : 어떠한 곳으로 무언가를 통해 간다고 했을 때 '어떠한 곳'
- `간선` : '무언가'
  - `단방향 간선` : 짝사랑
  - `양방향 간선`: 사귐
  - `outdegree`: 정점으로 나가는 간선
  - `indegree`: 들어오는 간선
- 정점의 약자는 V또는 U라고 한다.
- 정점과 간선으로 이루어진 집함을 그래프라고 한다.
- `가중치` : 간선과 정점 사이에 드는 비용
- 노드에서 노드까지 가는 비용이 한칸이면 가중치는 한칸



#### 트리

- 그래프 중 하나로 그래프의 특징처럼 정점과 간선으로 이루어져 있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합.
- `루트 노드`, `내부 노드`, `리프 노드` 등으로 구성
- 트리로 이루어진 집합은 숲이라고 한다.



##### 트리의 특징

1. 부모, 자식 계층 구조를 가진다
2. V - 1 : E
   - 간선수는 노드수 - 1
3. 임의의 두 노드 사이의 경로는 유일무이하게 존재한다.
   - 어떤 노드와 어떤 노드까지의 경로는 반드시 있다.

##### 트리의 구성

`루트 노드`

- 가장 위에 있는 노드
- 트리 탐색할 때 루트 노드를 중심으로 탐색하면 문제가 쉽게 풀리는 경우가 많다

`내부 노드`

- 루트 노드와 내부 노트 사이에 있는 노드를 뜻한다

`리프 노드`

- 자식 노드가 없는 노드



##### 트리의 높이와 레벨

`깊이` : 각 노드마다 다르며, 루트 노드부터 특정 노드까지 최단거리로 갔을 떄의 거리

`높이` : 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리를 의미

`레벨` : 보통 깊이와 같은 의미를 지닌다.

- 1번 노드를 0레벨이라고 하고 2번 노드, 3번 노드까지 레벨을 1레벨이라고 할 수 있다.

`서브트리` : 트리 내의 하위 집합. 트리 내에 있는 부분집합



##### 이진 트리

자식의 노드 수가 두 개 이하인 트리

`정이진 트리(full binary tree)` : 자식 노드가 0 또는 두 개인 이진 트리

`완전 이진 트리(complete binary tree)` : 왼쪽에서부터 채워져 있는 이진 트리. 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있음

`변질 이진 트리(degenerate binary tree)` : 자식 노드가 하나밖에 없는 이진 트리를 의미합니다.

`포화 이진 트리(perfect binary tree)`: 모든 노드가 꽉 차 있는 이진 트리를 의미합니다.

`균형 이진 트리(balanced binary tree)`: 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리를 의미합니다. map, set을 구성하는 레드 블랙 트리는 균형 이진 트리 중 하나입니다.

