## 메모리

CPU는 메모리에 올라와 있는 프로그램의 명령어들을 실행할 뿐이다

### 메모리 계층

`레지스터`

- CPU 안에 있는 작은 메모리
- 휘발성
- 속도 가장 빠름
- 기억 용량이 가장 적음

`캐시`

- `L1, L2 캐시`를 지칭

- 휘발성
- 속도 빠름
- 기억용량 적음

`주기억장치`

- `RAM`을 가리킴
- 휘발성
- 속도 보통
- 기억 용량이 보통

`보조기억장치`

- `HDD`, `SDD`를 일컬음
- 휘발성
- 속도 낮음
- 기억 용량이 많음

`램`: 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요시마다 CPU 에 빠르게 전달하는 역할

특징

- 계층 위로 올라갈 수록 가격은 비싸지는데 용량은 작아지고 속도는 빨라짐

메모리 계층이 있는 이유

- 경제성
  - 예) `16GB RAM` 8만원 `16GB SSD` 훨씬 싼 가격에 살 수 있음
- 캐시

게임을 실행하다 보면 '로딩 중'이라는 메시지 나오는데, 이는 하드디스크 또는 인터넷에서 데이터를 읽어 RAM으로 전송하는 과정이 아직 끝나지 않음

#### 캐시(cache)

데이터를 미리 복사해 놓는 임시 저장소

빠른 장치와 느린 장치에서 속도 차이에 따른 `병목 현상`을 줄이기 위한 메모리

이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약

`캐싱 계층` : 메모리와 CPU 사이의 속도 차이가 너무 크기 때문에 중간에 레지스터 계층을 둬서 속도 차이를 해결하는데 이렇게 계층과 계층 사이에 있는 계층

예) `캐시 메모리`와 `보조기억장치` 사이에 있는 `주기억장치`는 `보조기억장치`의 `캐싱 계층`

##### 지역성의 원리

캐시 계층을 두는 것 말고 캐시를 직접 설정 : 자주 세용하는 데이터를 기반으로 설정

`지역성의 원리` : 자주 사용하는 데이터에 대한 근거

###### 시간 지역성(temporal locality)

최근 사용한 데이터에 다시 접근하려는 특성

예) `for 반복문`으로 이루어진 코드 안의 변수 `i` 최근에 사용했기 때문에 계속 접근해서 `+1` 연달아 함

###### 공간 지역성(spatial locality)

최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

예) 공간을 나타내는 배열 `arr`의 각 요소들에 `i`가 할당되며 해당 배열에 연속적으로 접근

#### 캐시히트와 캐시미스

`캐시히트`: 캐시에서 원하는 데이터를 찾음

- 캐시히트를 하게되면 해당 데이터를 제어장치를 거쳐 가져오게 됨

- 캐시히트의 경우 위치도 가깝고 CPU 내부 버스를 기반으로 작동해서 빠름

`캐시미스`: 해당 데이터가 캐시에 없다면 주 메모리로 가서 데이터를 찾아오는 것

- 메모리에서 가져오게 됨
- 시스템 버스를 기반으로 작동하기 때문에 느림

##### 캐시매핑

캐시가 히트되기 위해 매핑하는 방법

CPU의 레지스터와 주 메모리(RAM)간에 데이터를 주고받을 때를 기반으로 설명

레지스터는 주 메모리에 비하면 굉장히 작고 주 메모리는 굉장히 크기 때문에 작은 레지스터가 캐시 계층으로써 역할을 잘 해주려면 이 매핑을 어떻게 하느냐가 중요

| 이름                                     | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| 직접 매핑 (directed mapping)             | 메모리가 1~100이 있고 캐시가 1~10이 있다면 1:1~10, 2:1~20... 이런 식으로 매핑하는 것을 말합니다. 처리가 빠르지만 충돌 발생이 잦습니다. |
| 연관 매핑 (associative mapping)          | 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑합니다.  충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느립니다. |
| 집합 연관 매핑 (set associative mapping) | 직접 매핑과 연관 매핑을 합쳐 놓은 것입니다. 순서는 일치시키지만 집합을 둬서 저장하며 불록화되어 있기 때문에 검색은 좀 더 효율적입니다. 예를 들어 메모리가 1~100이 있고 캐시 1~10이 있다면 캐시 1~5에는 1~50의 데이터를 무작위로 저장시키는 것 |

##### 웹 브라우저의 캐시

소프트웨어적인 대표적인 캐시

- 웹 브라우저의 작은 저장소 쿠키
- 로컬 스토리지
- 세션 스토리지

보통 사용자의 커스텀한 정보나 인증 모듈관련 사항들을 웹브라우저에 저장해서 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰임

###### 쿠키

만료기한이 있는 키-값 저장소

- `same-site 옵션`을 `strict`로 설정하지 않았을 경우 다른 도메인에서 요청했을 때 자동 전송

- 4KB까지 데이터를 저장할 수 있다
- 만료기한을 정할 수 있다

쿠키를 설정할 때는 `document.cookie`로 쿠키를 볼 수 없게 `httponly` 옵션을 거는 것이 중요

클라이언트 또는 서버에서 만료기한 등을 정할 수 있는데 보통 서버에서 정함

###### 로컬 스토리지

만료기한이 없는 키-값 저장소

- 10MB까지 저장
- 웹 브라우저를 닫아도 유지됨
- 도메인 단위로 저장, 생성
- `HTML5`를 지원하지 않는 웹 브라우저에서는 사용할 수 없음
- 클라이언트에서만 수정 가능

###### 세션 스토리지

만료기한이 없는 키-값 저장소

- 탭 단위로 세션 스토리지를 생성, 탭을 닫을 때 해당 데이터가 삭제
- 5MB까지 저장이 가능
- HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없음
- 클라이언트에서만 수정 가능

##### 데이터베이스의 캐싱 계층

데이터베이스 시스템을 구축할 때 메인 데이터베이스 위에 `레디스(redis)` 데이터베이스 계층을 `캐싱 계층`으로 둬서 성능을 향상시키기도 함

### 메모리 관리

#### 가상 메모리(virtual memory)

컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것

`가상 주소(logical address)`: 가상적으로 주어진 주소

`실제 주소(physical address)`: 실제 메모리상에 있는 주소

가상 주소는 `메모리관리장치(MMU)`에 의해 실제 주소로 변환

사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축할 수 있음

가상 메모리는 `페이지 테이블`로 관리됨

`페이지 테이블`: 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있음

속도 향상을 위해 `TLB`를 사용

`TLB`: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층

##### 스와핑

`페이지 폴트` : 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 발생

`스와핑`을 통해 RAM을 효과적으로 관리하고 이를 방지

- 당장 사용하지 않는 영역을 하드디스크로 옮김
- 필요할 때 다시 RAM으로 불러와 올림
- 사용하지 않으면 다시 하드디스크로 내림을 반복

##### 페이지 폴트(page fault)

프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의  RAM에는 없는 데이터에 접근했을 경우 발생

운영체제는 다음 과정으로 해당 데이터를 메모리로 가져와서 마치 페이지 폴트가 전혀 발생하지 않은 것처럼 프로그램이 작동하게 해줌

`페이지 폴트`, `스와핑` 과정

1. `CPU`는 `물리 메모리`를 확인하여 해당 페이지가 없으면 `트랩`을 발생하여 운영체제에 알립니다.
2. `운영체제`는 `CPU`의 동작을 잠시 멈춥니다.
3. `운영체제`는 `페이지 테이블`을 확인하여 `가상 메모리`에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하고 현재 `물리 메모리`에 비어 있는 `프레임`이 있는지 찾습니다. `물리 메모리`에도 없다면 `스와핑`이 발동됩니다.
4. 비어 있는 프레임에 해당 페이지를 로드하고, `페이지 테이블`을 최신화합니다.
5. 중단되었던 `CPU`를 다시 시작합니다.

`페이지(page)`: 가상 메모리를 사용하는 최소 크기 단위

`프레임(frame)`: 실제 메모리를 사용하는 최소 크기 단위

#### 스레싱(thrashing)

`메모리`의` 페이지 폴트율`이 높은 것을 의미

컴퓨터의 심각한 성능 저하를 초래

원인 : 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생

- `페이지 폴트`가 일어나면 `CPU 이용률`이 낮아짐

- `CPU 이용률`이 낮아지게 되면 운영체제는 CPU가 한가한가라고 생각함
- 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올리게됨

이와 같은 악순환이 반복되며 스레싱이 일어나게 됨

해결방법

- 메모리를 늘림
- `HDD`를 사용한다면 `HDD`를 `SDD`로 바꿈

운영체제에서 해결방법

- `작업세트`
- `PFF`

##### 작업 세트(working set)

프로세스의 과거 사용 이력인 `지역성(locality)`을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드

효과

- 탐색에 드는 비용을 줄일 수 있음
- 스와핑 줄일 수 있음

##### PFF(Page Fault Frequency)

페이지 폴트 빈도를 조절하는 방법

- 상한선과 하한선을 만듬
- 상한선에 도달한다면 페이지를 늘림
- 하한선에 도달한다면 페이지를 줄임

#### 메모리 할당

메모리에 프로그램을 할당할 때 기반

- 시작 메모리 위치
- 메모리의 할등 크기

##### 연속 할당

메모리에 연속적으로 공간을 할당

프로세스A와 프로세스B 프로세스C가 순차적으로 공간에 할당

###### 고정 분할 방식(fixed partition allocation)

메모리를 미리 나누어 관리하는 방식

- 메모리가 미리 나뉘어 있기 때문에 융통성이 없음
- 내부 단편화가 발생

###### 가변 분할 방식(variable partition allocation)

매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용

- 내부 단편화는 발생하지 않고 외부 단편화는 발생할 수 있음

| 이름     | 설명                                                        |
| -------- | ----------------------------------------------------------- |
| 최초적합 | 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당합니다.   |
| 최적적합 | 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당합니다. |
| 최악적합 | 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당합니다.    |

`내부 단편화(internal fragmentation)`: 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상

`외부 단편화(external fragmentation)`: 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상

`홀(hole)`: 할당할 수 있는 비어 있는 메모리 공간

##### 불연속 할당

메모리를 연속적으로 할당하지 않는 방법

현대 운영체제가 쓰는 방법

###### 페이징

동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스 할당

프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당

장점

- 홀의 크기가 균일하지 않은 문제가 없어짐

단점

- 주소 변환이 복잡해짐

###### 세그멘테이션(segmentation)

페이지 단위가 아닌 의미 단위인 `세그먼트(segment)`로 나누는 방식

프로세스 구성 : `코드`, `데이터`, `스택`, `힙`

`코드`와 `데이터` 등을 기반으로 나눌 수도 있으며 함수 단위로도 나눌 수 있음

장점

- 공유와 보안 측면

단점

- 홀 크기가 균일하지 않음

###### 페이지드 세그멘테이션(paged segmentation)

공유나 보안을 의미 단위의 세그먼트로 나눔

물리적 메모리는 페이지로 나눔

#### 페이지 교체 알고리즘

메모리는 한정되어 있기 때문에 스와핑이 많이 일어남

스와핑은 많이 일어나지 않도록 설계되어야 하며 이는 페이지 교체 알고리즘을 기반으로 스와핑이 일어남

##### 오프라인 알고리즘(offline algorithm)

먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘

가장 좋은 방법

사용할 수 없는 알고리즘

다른 알고리즘과의 성능 비교에 대한 기준을 제공

##### FIFO(First In First Out)

가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법

##### LRU(Last Recently Used)

참조가 가장 오래된 페이지를 바꿈

문제점

- 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 함

프로그래밍으로 구현할 때는 두 개의 자료 구조로 구현

- `해시 테이블` : 이중 연결 리스트에서 빠르게 찾을 수 있도록 사용
- `이중 연결 리스트` : 한정된 메모리를 나타냄

###### NUR(Not Used Recently)

일명 `clock 알고리즘`

- `0`과 `1`을 가진 비트를 둠

- 시계 방향을 돌면서 `0`을 찾고 `0`을 찾은 순간 해당 프로세스를 교체

- 해당 부분을 `1`로 바꿈

`1`은 최근에 참조되었고 `0`은 참조되지 않음을 의미

##### LFU(Least Frequently Used)

가장 참조 횟수가 적은 페이지를 교체

많이 사용되지 않은 것을 교체
