# 데이터베이스

## ERD와 정규화 과정

`ERD(Entity Relationship Diagram)`: 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것

만약 서비스를 구축한다면 가장 먼저 신경써야할 부분이며 이 부분을 신경 쓰지 않고 서비스를 구축한다면 단단하지 않은 골조로 건물을 짓는 것이나 다름없음

### ERD의 중요성

ERD는 시스템의 요구 사항을 기반으로 작성

ERD를 기반으로 데이터베이스를 구축

데이터베이스를 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할 담당

장점

- 관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용

단점

- 비정형 데이터를 충분히 표현할 수 없다

`비정형 데이터` : 비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보

### 예제로 배우는 ERD

#### 승원 영업부서의 ERD

##### 요구사항

- 영업사원은 0~n명의 고객을 관리한다
- 고객은 0~n개의 주문을 넣을 수 있다
- 주문에는 1~n개의 상품이 들어간다

#### 무무오브레전드의 ERD

##### 요구사항

- 선수들은 1명의 챔피언을 고를 수 있다
- 챔피언은 한 개 이상의 스킬을 갖는다
- 스킬은 한 개 이상의 특성을 갖는다

### 정규화 과정

릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결

또는, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

`데이터베이스 이상 현상`

회원이 한 개의 등급을 가져야 하는데 세 개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고, 데이터를 삽입해야 하는데 하나의 필드 값이 NULL이 되면 안 되어서 삽입하기 어려운 현상을 말합니다.

정규화 과정은 정규형 원칙을 기반으로 정규형을 만들어가는 과정

정규화된 정도 - 정규형(NF, Normal Form)으로 표현

기본 정규형 : 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형

고급 정규형: 제4정규형, 제5정규형

#### 정규형 원칙

- 같은 의미를 표현하는 릴레이션 좀 더 좋은 구조로 만들어야 함

- 자료의 중복성은 감소해야 함
- 독립적인 관계는 별개의 릴레이션으로 표현해야 함
- 각각의 릴레이션은 독립적인 표현이 가능해야 함

#### 제1정규형

릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 함

릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안됨, 있다면 제거

| 유저번호 | 유저ID | 수강명                      | 성취도     |
| -------- | ------ | --------------------------- | ---------- |
| 1        | 홍철   | {C++코딩테스트, 프런트특강} | {90%, 10%} |
| 2        | 범석   | {코드포스특강, DS특강}      | {7%, 8%}   |

->

| 유저번호 | 유저ID | 수강명        | 성취도 |
| -------- | ------ | ------------- | ------ |
| 1        | 홍철   | C++코딩테스트 | 90%    |
| 1        | 홀철   | 프런트특강    | 10%    |
| 2        | 범석   | 코드포스특강  | 7%     |
| 2        | 범석   | DS특강        | 8%     |

앞의 그림처럼 홍철이란 ID에 수강명이 {C++코딩테스트, 프런트특강}이 있었는데 이것을 나눠서 반복 집합을 제거

#### 제2정규형

릴레이션이 제1정규형

부분 함수의 종속성을 제거한 형태

부분 함수의 종속성 제거 : 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것

| 유저번호 | 유저ID | 수강명        | 성취도 |
| -------- | ------ | ------------- | ------ |
| 1        | 홍철   | C++코딩테스트 | 90%    |
| 1        | 홀철   | 프런트특강    | 10%    |
| 2        | 범석   | 코드포스특강  | 7%     |
| 2        | 범석   | DS특강        | 8%     |

->

| 유저번호 | 유저ID |
| -------- | ------ |
| 1        | 홍철   |
| 2        | 범석   |

| 유저ID | 수강명        | 성취도 |
| ------ | ------------- | ------ |
| 홍철   | C++코딩테스트 | 90%    |
| 홀철   | 프런트특강    | 10%    |
| 범석   | 코드포스특강  | 7%     |
| 범석   | DS특강        | 8%     |

분리

- 기본키인 {유저ID, 수강명}과 완전 종속된 유저번호 릴레이션
- {유저 ID, 수강명}에 따른 성취도 릴레이션으로 분리

주의할 점

- 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 함
- 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 함

#### 제3정규형

제 2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속(transsitive FD)을 만족하지 않는 상태

##### 이행적 함수 종속

A->B와 B->C가 존재하면 논리적으로 A->C가 성립

이때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 함

예) 무무쇼핑몰

유저ID와 등급, 할인율이 정해져 있는 테이블을 다음과 같이 분해

| 유저ID | 등급     | 할인율 |
| ------ | -------- | ------ |
| 홍철   | 플래티넘 | 30%    |
| 범수   | 다이아   | 50%    |
| 가영   | 마스터   | 70%    |

->

| 유저ID | 등급     |
| ------ | -------- |
| 홍철   | 플래티넘 |
| 범수   | 다이아   |
| 가영   | 마스터   |

| 등급     | 할인율 |
| -------- | ------ |
| 플래티넘 | 30%    |
| 다이아   | 50%    |
| 마스터   | 70%    |

#### 보이스/코드 정규형(BCNF)

제 3정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

`결정자`: 함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소, 'X->Y'일 떄 X는 결정자, Y는 종속자이다.

요구 사항

- 각 수강명에 대해 한 학생은 오직 한 강사의 강의만 수강한다
- 각 강사는 한 수강명만 담당한다
- 한 수강명은 여러 강사가 담당할 수 있다

| 학번  | 수강명     | 강사 |
| ----- | ---------- | ---- |
| 12010 | 코딩테스트 | 큰돌 |
| 12010 | MEVN       | 재엽 |
| 12011 | 코딩테스트 | 큰돌 |
| 12011 | MEVN       | 가영 |
| NULL  | 롤         | 범석 |

앞의 릴러이션을 보면 {학번, 수강명} 또는 {학번, 강사}가 후보키가 됨

문제점

- 범석이라는 강사가 '롤'이라는 수강명을 담당한다고 했을 떄, 이를 삽입하면 학변이 NULL이 됨

이 릴레이션은 다음과 같은 함수 종속 다이어그램을 가짐

강사 속성이 결정자이지만 후보키가 아니므로 이 강사 속성을 분리해야 한다

| 학번  | 강사 |
| ----- | ---- |
| 12010 | 큰돌 |
| 12010 | 재엽 |
| 12011 | 큰돌 |
| 12011 | 가영 |

| 수강명     | 강사 |
| ---------- | ---- |
| 코딩테스트 | 큰돌 |
| MEVN       | 재엽 |
| MEVN       | 가영 |
| 롤         | 범석 |

롤-범석이 제대로 들어갔으며 학번-강사/수강명-강사로 잘 분해됨

#### 종합

정규형 과정을 거쳐 테이블을 나눈다고 해서 성능이 좋아지는 것은 아님

성능이 좋아질 수도 나빠질 수도 있음

테이블을 나누게 되면 어떠한 쿼리는 조인을 해야 하는 경우도 발생해서 오히려 느려질 수도 있음

서비스에 따라 정규화 또는 비정규화 과정을 진행해야 함

## 트랜잭션과 무결성

### 트랜잭션

데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위

데이터베이스에 접근하는 방법은 쿼리이므로, 여러 개의 쿼리들을 하나로 묶는 단위

특징

- 원자성
- 일관성
- 독립성
- 지속성

이를 한꺼번에 ACID 특징이라고 함

#### 원자성(atomicity)

트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징

예) 트랜잭션 커밋했는데, 문제가 발생하여 롤백하는 경우 

- 그 이후에 모두 수행되지 않음을 보장하는 것

예) 1000만원을 가진 홍철이가 0원을 가진 규영이에게 500만원을 이체

- 결과 : 홍철이 500만원, 규영이 500만원

해당 결과는 다음과 같은 operation 단위들로 이루어진 과정을 거침

1. 홍철의 잔고를 조회한다
2. 홍철에게서 500만원을 뺸다
3. 규영에게서 500만원을 넣는다

여기서 1~3의 operation 중 데이터베이스 사용자는 이 세 가지의 과정을 볼 수도 참여할 수도 없음

이 과정이 모두 끝난 이후의 상황인 홍철 500만원, 규영 500만원인 상황만 봄

여기서 이 작업이 취소될 경우 

- 홍철 : 1000만원, 규영 : 0원

- 홍철: 500만원, 규영 : 0원 처럼 일부 operation만 적용된 상황 되지 않음

그래서 all or nothing

트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안됨

만약 있다면 롤백이 일어났을 때

- 어떻게 해야 할 것인지에 대한 해결방법이 있어야 함
- 트랜잭션 전파를 신경써서 관리해야 함

##### 커밋과 롤백

`커밋(commit)`

- 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어

- 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것
- 커밋이 수행되었다 : 하나의 트랜잭션이 성공적으로 수행되었다

​    update -> insert -> delete -> 데이터베이스에 영구 저장

커밋시작----트랜잭션-------커밋 종료

앞의 그림처럼 update, insert, delete의 쿼리가 하나의 트랜잭션 단위로 수행되고 이후에 데이터베이스에 영구 저장

`롤백`: 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 한다면 사용하는 것

- 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)

커밋과 롤백 덕에 

- 데이터의 무결성이 보장됨

- 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있음

- 해당 작업을 그룹화할 수 있음

##### 트랜잭션 전파

트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행

문제 : 이를 넘겨주기가 어렵기도 하고 귀찮기도 함

`트랜잭션 전파`: 이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 매서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것

Spring 프레임워크에서는 @Transactional 애너테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리

#### 일관성(consistency)

'허용된 방식'으로만 데이터를 변경해야 하는 것

데이터베이스에 기록된 모든 데이터는 여러가지 조건, 규칙에 따라 유효함을 가져야 함

예) 홍철이 1000만원, 범석이 0원

범석이가 필자한테 500만원 입금하는 것은 불가능

#### 격리성(isolation)

트랜잭션 수행 시 서로 끼어들지 못하는 것

복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 함

데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함

순차적으로 하면 쉽게 되지만 성능이 나쁨

격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장

격리 수준

- READ_UNCOMMITTED
- READ_COMMITTED
- REPEATABLE_READ
- SERIALIZABLE

위로 갈수록 동시성이 강해지지만 격리성은 약해짐

아래로 갈수록 동시성은 약해지고 격리성은 강해짐

각 단계마다 나타나는 현상

- REAPEATABLE_READ : 팬텀 리드

- READ_COMMITED : 팬텀 리드, 반복 가능하지 않은 조회

- READ_UNCOMMITED : 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드

##### 격리 수준에 따라 발생하는 현상

###### 팬텀 리드(phantom read)

한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우

예) 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보냄

세 개의 테이블이 조회

사용자 B가 age가 15인 회원 레코드를 삽입

그러면 그 다음 세 개가 아닌 네 개의 테이블이 조회됨

###### 반복 가능하지 않은 조회(non-repeatable read)

한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우

예) 

- 사용자 A가 큰돌의 보석개수가 100개 값 데이터

- 사용자 B가 그 값을 1로 변경해서 커밋

- 사용자 A는 100이 아닌 1을 읽음

팬텀 리드와 다른 점

- 반복 가능하지 않은 조회는 행 값이 달라질 수도 있음
- 팬텀 리드는 다른 행이 선택될 수도 있음

###### 더티 리드(dirty read)

반복 가능하지 않은 조회와 유사

한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생

예)

- 사용자 A가 큰돌의 보석 개수 100을 1로 변경한 내용이 커밋되지 않은 상태

- 그 이후 사용자 B가 조회한 결과가 1로 나옴

##### 격리 수준

###### SERIALIZABLE

트랜잭션을 순차적으로 진행시키는 것

여러 트랜잭션이 동시에 같은 행에 접근할 수 없음

매우 엄격한 수준으로 해당 행에 대해 격리 시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야 함

교착 상태가 일어날 확룰 많음

가장 성능이 떨어짐

###### REPEATABLE_READ

하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아줌

새로운 행을 추가하는 것은 막지 않음

이후에 추가된 행이 발견될 수도 있음

###### READ_COMMITTED

가장 많이 사용되는 격리 수준

`MySQL8.0`, `PostgreSQL`, `SQL Server`, `오라클`에서 기본값으로 설정

`READ_UNCOMMITTED`와는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음

커밋 완료된 데이터에 대해서만 조회를 허용

어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있음

예) 트랜잭션 A가 수정한 행 트랜잭션 B가 수정할 수 있음

- 이 때문에 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있음

###### READ_UNCOMMITTED

가장 낮은 격리 수준

하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있음

가장 빠름

데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적

몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 어림잡아 집계하는 데 사용하면 좋음

#### 지속성(durability)

성공적으로 수행된 트랜잭션은 영원히 반영되어야 함

데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함

데이터베이스가 이를 위해 제공하는 기능

- 체크섬
- 저널링
- 롤백

`체크섬`: 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법

`저널링`: 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

### 무결성

무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것

무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치 하는지에 대한 신뢰가 생김

무결성의 종류

- `개체 무결성`: 기본키로 선택된 필드는 빈 값을 허용하지 않음
- `참조 무결성`: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함
- `고유 무결성`: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가집니다.
- `NULL 무결성`: 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속상 값은 NULL이 될 수 없다는 제약조건

