

##### 이진 탐색 트리

- 노드의 오른쪽 하위 트리에는 '노드 값보다 큰 값'이 있는 노드만 포함되고, 왼쪽 하위 트리에는 '노드 값보다 작은 값'이 들어 있는 트리
- 왼쪽 및 오른쪽 하위 트리도 해당 특성을 가집니다.
- 왼쪽에는 작은 값, 오른쪽에는 큰 값이 이미 정해져 있기 때문에 검색을 하기 용이하다.
- 요소를 찾을 때 O(logn)이 걸리며 최악의 경우 O(n)이 걸린다.
- 이는 삽입 순서에 따라 선형적일 수 있기 때문이다

Q. 이진 탐색 트리에서 3 오른쪽에 2가 들어갔는데 이게 맞나

##### AVL 트리

- 앞서 설명한 최악의 경우 선형적인 트리가 퇴는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리
- 두 자식 서브트리의 높이는 항상 최대 1만큼 차이 난다
- 탐색, 삽입, 삭제 모두 시간복잡도가 O(logn)
- 삽입, 삭제를 할 때마다 균형이 안 맞는 것을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전

##### 레드 블랙 트리

- 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn
- 각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장
- 삽입 및 삭제 중에 트리가 균형을 유지하는데 사용됨
- `C++ STL의 set, multiset, map and multimap`이 이 레드 블랙 트리를 이용하여 구현되어 있습니다.
- 모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다 등의 규칙을 기반으로 균형을 잡음

##### 힙

- 힙은 완전 트리 기반의 자료 구조

- 각 힙에 따라 특정한 특징을 지킨 트리
- 힙에는 어떠한 값이 들어와도 특정 힙의 규칙을 지키게 만들어져 있다.

###### 최대힙 

- 루트 노드에 있는 키는 모든 자식이 있는 키 중에서 가장 큼

- 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어짐

###### 최소힙

- 루트 노드에 있는 키는 모든 자식 중에서 최솟값이여야 함
- 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이뤄져야 함

###### 최대힙의 삽입

- 새로운 노드 삽입시, 마지막 노드에 이어서 삽입
- 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족시킴ㅁ

###### 최대힙의 삭제

- 최대값은 루트 노드이므로 루트 노드가 삭제되고 , 그 이후 마지막 노드와 루트 노드를 스왑하여 또다시 스왑 등의 과정을 거쳐 재구성됩니다.



#### 우선순위 큐

- 우선순위 대기열이라고도 하며, 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조
- 힙을 기반으로 구현

- greater를 써서 오름차순, less를 써서 내림차순으로 바꿀 수 있다.
- int뿐만 아니라 다른 자료 구조를 넣어서 할 수도 있다.



#### 맵

- 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조
- 레드 블랙 트리 자료 구조를 기반으로 형성
- 삽입하면 자동으로 정렬
- `map<string, int>` 형태로 구현
- clear()함수로 맵에 있는 모든 요소를 삭제할 수 있음
- size()로  map의 크기를 구할 수 있다.
- erase()로 해당 키와 키에 매핑된 값을 지울 수 있다.
- 해시 테이블을 구현할 때 쓰며 정렬을 보장하지 않는 unordered_map과 정렬을 보장하는  map 두가지가 있다.
- 키에 해당하는 key를 first, 키에 매핑된 값(value)에 해당하는 값을 second로 탐색 가능



#### 셋

- 특정 순서에 따라 고유한 요소를 저장하는 컨테이너
- 중복되는 요소는 없고 오로지 희소한 값만 저장하는 자료 구조
- pair는 두가지 형을 담을 수 있는 구조이며 first, second로 그 인자에 접근 가능
- 나머지 사항은 map과 비슷



#### 해시 테이블

- 무산에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
- 삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도를 가짐
- unordered map으로 구현