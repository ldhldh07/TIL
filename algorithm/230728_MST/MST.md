```python
import heapq

def prim(graph, start):
    mst = list()
    edges = [(0, start)]
    visited = [False] * len(graph)

    while edges:
        weight, node = heapq.heappop(edges)

        if not visited[node]:
            visited[node] = True
            mst.append((node, weight))

            for weight, edge in graph[node]:
                if not visited[edge]:
                    heapq.heappush(edges, (weight, edge))

    return mst

# 그래프 예시 (인접 리스트 형태)
graph = [
    [],  # 0번 노드는 사용하지 않음
    [(7, 2), (5, 4)],  # (가중치, 노드)
    [(7, 1), (9, 4), (8, 3), (7, 5)],
    [(8, 2), (5, 5)],
    [(5, 1), (9, 2), (7, 5), (6, 6)],
    [(7, 2), (5, 3), (7, 4), (8, 6), (9, 7)],
    [(6, 4), (8, 5), (11, 7)],
    [(9, 5), (11, 6)]
]

print(prim(graph, 1))  # Start from 1
```

이 코드는 가중치를 기준으로 최소 힙을 구성하므로, 가중치에 따른 간선 선택이 더 효율적으로 이루어집니다.



사실 프림 알고리즘과 크루스칼 알고리즘은 모두 최소 신장 트리를 찾는 알고리즘이지만, 그 작동 방식과 필요한 자료 구조가 다릅니다.

- **크루스칼 알고리즘**은 모든 간선을 가중치에 따라 오름차순으로 정렬한 뒤, 가장 가중치가 낮은 간선부터 차례대로 선택합니다. 이때 간선을 선택하면서 싸이클이 생성되지 않도록 하는데, 이를 위해 유니온-파인드(Union-Find) 알고리즘이 필요합니다.
- 반면에 **프림 알고리즘**은 특정 시작 노드에서 시작하여 그래프의 모든 노드를 연결하는 데 필요한 가장 가중치가 낮은 간선을 찾아나갑니다. 이때 선택되는 간선들은 자동으로 싸이클을 형성하지 않게 됩니다. 그래서 프림 알고리즘은 유니온-파인드 알고리즘이 필요하지 않습니다.

두 알고리즘 모두 최소 신장 트리를 찾는 것이 목표이지만, 선택하는 간선들의 순서와 싸이클 형성 방지 방법이 다르다는 점에서 차이가 있습니다.

크루스칼 알고리즘과 프림 알고리즘의 시간 복잡도는 주로 그래프의 간선 수(E)와 노드 수(V)에 의해 결정됩니다.

- **크루스칼 알고리즘**은 간선을 오름차순으로 정렬하는 과정이 필요하므로, 이 부분에서 O(ElogE)의 시간 복잡도가 소요됩니다. 그리고 간선을 순회하면서 싸이클 여부를 확인하는 과정에서 유니온-파인드 알고리즘을 사용하므로 이 부분에서 약 O(Elog*V)의 시간 복잡도가 추가로 소요됩니다. 따라서 크루스칼 알고리즘의 전체 시간 복잡도는 O(ElogE + Elog*V)가 됩니다.
- **프림 알고리즘**의 경우, 각 노드에 대해 연결된 간선 중 가장 가중치가 작은 간선을 찾는 과정이 필요하므로, 이를 위해 우선순위 큐(힙)를 사용하면 약 O((E+V)logV)의 시간 복잡도가 소요됩니다.

따라서 두 알고리즘의 시간 복잡도는 크게 차이나지 않습니다. 특정 상황에서 어떤 알고리즘이 더 빠를지는 그래프의 특성(간선과 노드의 수, 그래프의 밀집도 등)에 따라 다를 수 있습니다. 예를 들어, 간선의 수가 매우 많고 밀집된 그래프에서는 프림 알고리즘이, 노드의 수는 많지만 간선의 수가 적은 희소한 그래프에서는 크루스칼 알고리즘이 더 효율적일 수 있습니다.



크루스칼 알고리즘은 모든 간선을 정렬한 후, 가장 가중치가 작은 간선부터 추가해가면서 MST를 만드는 알고리즘이므로, 유니온-파인드 자료구조를 사용하여 사이클을 확인하게 됩니다.

아래는 파이썬을 사용한 크루스칼 알고리즘의 간단한 예시입니다:

```python
def find(parent, i):
    if parent[i] == i:
        return i
    return find(parent, parent[i])

def union(parent, rank, x, y):
    xroot = find(parent, x)
    yroot = find(parent, y)

    if rank[xroot] < rank[yroot]:
        parent[xroot] = yroot
    elif rank[xroot] > rank[yroot]:
        parent[yroot] = xroot
    else :
        parent[yroot] = xroot
        rank[xroot] += 1

def kruskal(graph):
    result = []
    i, e = 0, 0

    graph = sorted(graph,key=lambda item: item[2])
    parent = []
    rank = []

    for node in range(len(graph)):
        parent.append(node)
        rank.append(0)

    while e < len(graph) -1 :
        u,v,w = graph[i]
        i = i + 1
        x = find(parent, u)
        y = find(parent ,v)

        if x != y:
            e = e + 1
            result.append([u,v,w])
            union(parent, rank, x, y)      

    return result

# 그래프 예시 (u, v, weight)
graph = [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4]]
print(kruskal(graph))
```

이 코드에서 각각의 노드는 자기 자신을 부모로 가리키는 형태로 초기화하고, 간선을 가중치에 따라 정렬한 후 순서대로 선택하며 MST를 만들어갑니다. 선택하는 과정에서 사이클이 발생하지 않도록 유니온-파인드를 사용하여 부모를 찾고, 사이클이 발생하지 않을 경우 간선을 결과에 추가하고 두 노드를 합치게 됩니다.



1. **프림 알고리즘**:

프림 알고리즘은 특정 노드에서 시작하여 해당 노드에 연결된 가장 가중치가 작은 간선을 선택하여, MST를 만들어나가는 알고리즘입니다. 알고리즘은 다음과 같은 방식으로 진행됩니다:

- 첫 번째 노드를 선택하고, 선택된 노드 집합(S)에 추가합니다.
- 선택된 노드 집합(S)에 속하지 않은 노드 중에서 S에 속한 노드와 연결된 간선들 중에서 가장 가중치가 작은 간선을 찾아, 해당 간선에 연결된 노드를 S에 추가합니다.
- 위의 과정을 모든 노드가 S에 포함될 때까지 반복합니다.

이 과정을 통해 최소 신장 트리(MST)가 생성됩니다. 프림 알고리즘은 각 단계에서 최소 가중치 간선만을 선택하므로 그리디 알고리즘의 일종입니다.

1. **크루스칼 알고리즘**:

크루스칼 알고리즘은 모든 간선을 가중치에 따라 오름차순으로 정렬한 후, 가장 가중치가 작은 간선부터 선택하여 MST를 만들어 나가는 알고리즘입니다. 이 때, 사이클을 형성하는 간선은 제외하게 됩니다. 알고리즘은 다음과 같은 방식으로 진행됩니다:

- 모든 간선을 가중치에 따라 오름차순으로 정렬합니다.
- 가장 가중치가 작은 간선을 선택합니다. 이 때, 해당 간선이 MST에 사이클을 형성하면 선택하지 않습니다.
- 위의 과정을 모든 간선에 대해 수행합니다.

크루스칼 알고리즘은 간선 선택 시 사이클을 확인하기 위해 유니온-파인드 자료구조를 주로 사용하며, 이 또한 그리디 알고리즘의 한 종류입니다.

두 알고리즘 모두 그리디 알고리즘의 특성을 가지고 있어, 로컬 최적의 선택을 통해 전역 최적의 해답을 찾아내는 방식을 사용합니다. 이 때문에 두 알고리즘 모두 최소 신장 트리를 구하는 문제에 효과적입니다.



물론입니다, 아래에 프림 알고리즘과 크루스칼 알고리즘의 예시를 들어 설명하겠습니다.

다음과 같은 가중치가 부여된 그래프를 생각해봅시다.

```css
A--1--B
 | \    |
 |  \   |
 3   2  4
 |    \ |
 C--5--D
```

**프림 알고리즘**:

1. 시작 노드를 선택해봅시다. 이 경우, A를 선택했다고 가정합시다.
2. 선택된 노드와 연결된 간선 중 가장 가중치가 작은 간선을 선택하고, 해당 간선을 통해 연결된 노드를 선택 노드 집합에 추가합니다. 이 경우, A와 B를 연결하는 간선을 선택하고, B를 선택 노드 집합에 추가합니다.
3. 이제 선택 노드 집합은 {A, B}입니다. 이 노드들과 연결된 간선 중에서 가장 가중치가 작은 간선은 A와 D를 연결하는 간선입니다. 따라서 이 간선을 선택하고, D를 선택 노드 집합에 추가합니다.
4. 이제 선택 노드 집합은 {A, B, D}입니다. 이 노드들과 연결된 간선 중에서 가장 가중치가 작은 간선은 A와 C를 연결하는 간선입니다. 따라서 이 간선을 선택하고, C를 선택 노드 집합에 추가합니다.
5. 이제 선택 노드 집합은 {A, B, C, D}로, 모든 노드가 포함되어 있습니다. 따라서 알고리즘을 종료합니다. 선택한 간선들은 {A-B, A-D, A-C}로, 이 간선들로 구성된 트리가 최소 신장 트리가 됩니다.

**크루스칼 알고리즘**:

1. 모든 간선을 가중치에 따라 오름차순으로 정렬합니다. 정렬된 간선의 목록은 다음과 같습니다: {A-B, A-D, A-C, B-D, C-D}.
2. 가장 가중치가 작은 간선인 A-B를 선택합니다.
3. 다음으로 가장 가중치가 작은 간선인 A-D를 선택합니다.
4. 다음으로 가중치가 작은 간선인 A-C를 선택합니다.
5. 다음으로 가중치가 작은 간선인 B-D를 선택하려고 합니다. 하지만 이 간선을 선택하면 사이클이 생기므로 이 간선은 선택하지 않습니다.
6. 마지막으로 C-D 간선을 선택하려고 합니다. 이 간선을 선택하면 사이클이 생기므로 이 간선도 선택하지 않습니다.
7. 이제 모든 노드가 최소 신장 트리에 포함되어 있으므로 알고리즘을 종료합니다. 선택한 간선들은 {A-B, A-D, A-C}로, 이 간선들로 구성된 트리가 최소 신장 트리가 됩니다.

두 알고리즘 모두 같은 최소 신장 트리를 찾았지만, 과정은 약간 다릅니다. 이 예제는 작은 규모의 그래프에 대한 것이므로, 두 알고리즘 모두 비슷한 시간이 걸렸을 것입니다. 하지만, 큰 규모의 그래프에서는 두 알고리즘의 성능은 그래프의 특성과 연결 상태에 따라 다를 수 있습니다.

- 크루스칼 알고리즘: 간선의 개수 E에 대해 O(ElogE)의 시간 복잡도를 가지며, 간선이 많은 밀집 그래프(Dense Graph)에서는 프림 알고리즘보다 느릴 수 있습니다. 그러나 간선의 개수가 적은 희소 그래프(Sparse Graph)에서는 효과적일 수 있습니다. 또한 크루스칼 알고리즘은 간선에 대해 작업을 수행하므로, 그래프의 연결성이나 노드의 배치에 관계없이 일관된 성능을 제공합니다.
- 프림 알고리즘: 노드의 개수 V에 대해 O(V^2)의 시간 복잡도를 가집니다. 하지만 우선순위 큐를 이용하면 시간 복잡도를 O(ElogV)로 줄일 수 있습니다. 따라서 프림 알고리즘은 밀집 그래프에서 효과적일 수 있습니다. 그러나 프림 알고리즘은 시작 노드에서 시작하여 그래프를 탐색하므로, 그래프의 특정 부분이나 노드의 배치에 따라 성능이 달라질 수 있습니다.

두 알고리즘 모두 각각의 상황에서 장점을 가지고 있으므로, 특정 문제에 대한 최적의 해결책을 선택하기 위해서는 그래프의 특성과 문제의 요구사항을 고려해야 합니다.