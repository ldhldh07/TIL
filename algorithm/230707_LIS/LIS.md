이 문제는 가장 긴 증가하는 부분 수열(Longest Increasing Subsequence, LIS) 문제로 접근하면 풀 수 있습니다.

입력으로 주어진 아이들의 번호 순서에서 가장 긴 증가하는 부분 수열을 찾으면, 그 수열에 포함되지 않는 원소들이 옮겨져야 하는 아이들의 번호가 됩니다. 따라서 원래의 아이들의 수에서 가장 긴 증가하는 부분 수열의 길이를 빼주면, 옮겨져야 하는 아이들의 최소 수를 구할 수 있습니다.

다이나믹 프로그래밍을 이용해 LIS를 구하는 방법은 다음과 같습니다:

1. dp 리스트를 만들고, dp[0]을 1로 초기화합니다.
2. 2번째부터 N번째까지 각각의 아이에 대해서, 자신의 앞에 있는 아이들 중 자신보다 번호가 작은 아이들의 dp값 중 최대값에 1을 더한 값을 dp[i]로 설정합니다.
3. dp 리스트 중 최대값을 찾아서 이를 LIS의 길이로 설정합니다.

이후, 아이들의 총 수에서 LIS의 길이를 빼면, 옮겨져야 하는 아이들의 최소 수를 구할 수 있습니다.

이를 파이썬 코드로 나타내면 다음과 같습니다.

```python
N = int(input())
seq = list(map(int, input().split()))
dp = [1] * N

for i in range(N):
    for j in range(i):
        if seq[i] > seq[j]:
            dp[i] = max(dp[i], dp[j] + 1)

print(N - max(dp))

```

이 코드는 각 아이들에 대해 그 아이를 마지막으로 하는 가장 긴 증가하는 부분 수열을 찾아 dp 리스트에 저장하고, 그 중 가장 긴 것을 찾아서 LIS로 설정한 후, 전체 아이들의 수에서 LIS의 길이를 빼는 방식으로 문제를 해결합니다.



## 이진탐색

```python
import bisect

N = int(input())
seq = list(map(int, input().split()))
LIS = [seq[0]]

for i in range(1, N):
    if seq[i] > LIS[-1]:
        LIS.append(seq[i])
    else:
        LIS[bisect.bisect_left(LIS, seq[i])] = seq[i]

print(N - len(LIS))
```



 "이진 탐색을 이용한 가장 긴 증가하는 부분 수열(LIS) 찾기" 알고리즘입니다. 이것은 내가 처음에 설명한 동적 계획법(DP)를 이용한 LIS 알고리즘과는 약간 다릅니다.

이진 탐색을 이용한 LIS 알고리즘은 O(N log N)의 시간 복잡도로, DP 방식보다 빠르게 LIS를 찾을 수 있습니다. 이는 LIS 리스트를 유지하면서, 새로운 수가 LIS의 마지막 수보다 크면 LIS에 추가하고, 그렇지 않으면 이진 탐색을 이용해 해당 수가 들어갈 위치를 찾아 그 위치의 값을 해당 수로 업데이트하는 방식으로 동작합니다.

두 방법 모두 문제를 해결하는데 사용될 수 있으며, 이진 탐색을 이용한 방법이 좀 더 빠른 성능을 보여줍니다. 하지만, DP를 이용한 방법은 각 위치에서의 최적해를 찾아 전체 문제의 최적해를 찾는 동적 계획법의 특징을 잘 보여주므로, 알고리즘 학습의 관점에서는 중요한 방법론입니다.

이진 탐색을 이용한 가장 긴 증가하는 부분 수열(Longest Increasing Subsequence, LIS) 찾기 알고리즘의 원리는 다음과 같습니다:

이 알고리즘은 빈 LIS 리스트를 시작으로, 주어진 수열을 순회하며 아래와 같이 동작합니다.

1. 현재 숫자가 LIS의 마지막 숫자보다 크다면, LIS의 끝에 현재 숫자를 추가합니다. 이는 현재 숫자가 LIS를 증가시킬 수 있음을 의미합니다.
2. 그렇지 않다면, 이진 탐색을 이용해 현재 숫자가 LIS에 들어갈 위치를 찾아 해당 위치의 값을 현재 숫자로 업데이트합니다. 이는 LIS의 현재 위치의 값을 더 작은 값으로 바꿈으로써, 이후에 더 긴 증가하는 부분 수열을 만들 가능성을 높이는 것입니다.

이 알고리즘은 수열의 각 숫자를 한 번씩 확인하므로 시간 복잡도는 O(N)이고, 이진 탐색에는 logN의 시간이 소요되므로, 전체 시간 복잡도는 O(N log N)입니다.

예를 들어, 수열이 [3, 5, 2, 7, 4]라고 가정합시다. 알고리즘은 다음과 같이 동작합니다:

- 초기 LIS: []
- 3 추가: [3]
- 5 추가: [3, 5]
- 2를 이진 탐색으로 적절한 위치에 추가: [2, 5] (이 경우 3이었던 자리에 2가 들어갑니다.)
- 7 추가: [2, 5, 7]
- 4를 이진 탐색으로 적절한 위치에 추가: [2, 4, 7] (이 경우 5이었던 자리에 4가 들어갑니다.)

이렇게 되면, 마지막 LIS의 길이는 3이 됩니다. 실제 가장 긴 증가하는 부분 수열은 [3, 5, 7]이지만, 이 알고리즘은 가장 긴 증가하는 부분 수열의 '길이'만 찾는 것이 목적이므로, [2, 4, 7]이라는 결과도 충분히 유효합니다.

네, 맞습니다. 이 알고리즘이 관리하는 LIS 리스트의 각 위치에 있는 숫자는 해당 인덱스에서 만들 수 있는 증가하는 부분 수열의 마지막 숫자 중 가능한 가장 작은 숫자입니다.

예를 들어 [3, 5, 2, 7, 4]에서 LIS 리스트가 [2, 5, 7]이라면, 이는 각각 길이가 1, 2, 3인 증가하는 부분 수열에서 만들 수 있는 마지막 숫자 중 가능한 가장 작은 숫자를 의미합니다. 즉, "길이가 1인 증가하는 부분 수열의 마지막 숫자 중 가능한 가장 작은 숫자는 2", "길이가 2인 증가하는 부분 수열의 마지막 숫자 중 가능한 가장 작은 숫자는 5", "길이가 3인 증가하는 부분 수열의 마지막 숫자 중 가능한 가장 작은 숫자는 7"이 됩니다.

이 알고리즘의 핵심은 가능한 작은 숫자를 유지함으로써 뒤에 오는 숫자가 LIS를 더 길게 만들 가능성을 최대한 유지하는 것입니다. 이를 통해 전체 수열을 훑는 동안 가장 긴 증가하는 부분 수열의 길이를 효과적으로 찾을 수 있습니다.

이진 탐색을 이용한 가장 긴 증가하는 부분 수열(Longest Increasing Subsequence, LIS) 찾기 알고리즘도 일종의 동적 계획법(Dynamic Programming)으로 볼 수 있습니다.

기본적인 동적 계획법(DP) 알고리즘은 문제를 여러 하위 문제로 나누고, 각 하위 문제의 해결책을 저장하고 재사용함으로써 전체 문제를 해결합니다.

이 알고리즘에서는 "현재 인덱스까지에서의 가장 긴 증가하는 부분 수열"을 하위 문제로 볼 수 있으며, 이를 LIS 리스트에 저장합니다. 이때, 각 LIS의 위치에 저장되는 값은 해당 위치에서의 가장 작은 마지막 숫자입니다. 이 값들을 저장하고 업데이트함으로써 전체 수열에 대한 가장 긴 증가하는 부분 수열의 길이를 효율적으로 계산할 수 있습니다.

따라서, 이는 저장과 재사용을 통해 전체 문제를 해결하는 동적 계획법의 핵심 개념을 따르는 것으로 볼 수 있습니다. 이진 탐색은 이 동적 계획법을 더 효율적으로 만드는 데 사용되는 도구라고 할 수 있습니다.