0-1 너비 우선 탐색(Breadth-First Search, BFS)는 그래프에서 사용하는 탐색 알고리즘 중 하나로, 각 간선의 가중치가 0 또는 1인 그래프에 대해서 적용되는 방식입니다.

이 알고리즘은 그래프의 노드들을 시작 노드로부터의 거리에 따라 층을 나누고, 같은 층에 있는 노드들을 먼저 탐색한 후, 다음 층의 노드들을 탐색하는 방식으로 진행됩니다. 이런 방식으로 인해, BFS는 그래프에서 최단 경로를 찾는데에 효과적인 알고리즘이 됩니다.

0-1 너비 우선 탐색은 BFS를 조금 변형한 형태로, 간선의 가중치가 0 또는 1인 그래프에 대해서는 더욱 빠른 성능을 보입니다. 이 알고리즘은 시작 노드에서 각 노드까지의 최단 경로를 계산하는 데 사용됩니다.

이 방법의 기본 아이디어는 간선의 가중치가 0이면 현재 레벨(즉, 같은 층)의 노드로 취급하고, 가중치가 1이면 다음 레벨의 노드로 취급하는 것입니다. 따라서, 간선의 가중치에 따라 노드를 현재 큐 또는 다음 큐에 넣는 것입니다.

이렇게 함으로써, 모든 노드를 한 번씩만 방문하게 되어 BFS에 비해 효율적으로 동작합니다. 그래프의 노드 수를 n, 간선 수를 m이라고 할 때, 0-1 BFS의 시간 복잡도는 O(n + m)입니다.



0-1 너비 우선 탐색(BFS) 알고리즘을 파이썬으로 구현한 예시 코드입니다. 이 코드는 시작 노드에서 각 노드까지의 최단 경로를 찾습니다.

```python
from collections import deque

def zero_one_bfs(graph, start):
    # 무한대를 표현하기 위해 float('inf')를 사용합니다.
    distance = [float('inf')] * len(graph)
    distance[start] = 0

    # 덱(deque)을 초기화합니다. 덱은 양쪽 끝에서 삽입과 삭제가 가능한 자료구조입니다.
    queue = deque([start])

    while queue:
        node = queue.popleft()
        for neighbor, weight in graph[node]:
            if distance[node] + weight < distance[neighbor]:
                distance[neighbor] = distance[node] + weight
                # 가중치가 0이면, 이웃 노드를 큐의 앞쪽에 추가합니다.
                # 가중치가 1이면, 이웃 노드를 큐의 뒤쪽에 추가합니다.
                if weight == 1:
                    queue.append(neighbor)
                else:
                    queue.appendleft(neighbor)
    return distance
```

이 예시 코드에서 `graph`는 인접 리스트를 사용하여 표현되었습니다. 각 리스트의 요소는 (이웃 노드, 가중치)의 튜플로 구성되어 있습니다.

이 함수를 실행할 때는 그래프와 시작 노드의 인덱스를 인수로 전달해야 합니다. 이 함수는 시작 노드에서 각 노드까지의 최단 거리를 포함하는 리스트를 반환합니다. 노드까지의 경로가 존재하지 않는 경우, 해당 요소의 값은 무한대(`float('inf')`)가 됩니다.

알고리즘이 어떻게 동작하는지 이해하는 데 도움이 되길 바랍니다. 이 코드가 당신의 문제를 해결하는 데 유용하길 바랍니다!