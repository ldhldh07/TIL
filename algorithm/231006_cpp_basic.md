## 프로토타입

"프로토타입"이란 언어와 문맥에 따라 다양한 의미를 갖습니다. 여기서는 C++의 문맥에서 설명하겠습니다.

C++에서 "프로토타입"은 주로 함수나 메서드의 선언에 관한 것을 의미합니다. 함수의 프로토타입은 함수의 실제 정의(구현)보다 먼저 나타나며, 함수의 이름, 반환 타입, 매개변수의 타입 및 수를 지정합니다. 이렇게 하면 해당 함수를 호출하는 코드가 그 함수의 실제 정의보다 먼저 나오더라도 컴파일러가 어떻게 그 함수를 호출해야 하는지 알 수 있습니다.

예를 들어:

```c++
void printMessage();  // 프로토타입

int main() {
    printMessage();  // 함수 호출
    return 0;
}

void printMessage() {  // 함수의 실제 정의
    std::cout << "Hello, World!" << std::endl;
}
```

여기서 `void printMessage();`는 `printMessage` 함수의 프로토타입입니다. 이 프로토타입 덕분에 `main` 함수 내에서 `printMessage` 함수를 호출할 수 있습니다.

객체지향 프로그래밍에서 클래스의 멤버 함수에 대한 프로토타입(또는 선언)은 클래스 정의 내부에 나타나며, 해당 함수의 실제 구현은 클래스 정의 외부에서 나타날 수 있습니다.



### ::



C++에서 `::` 기호는 "범위 지정 연산자"(scope resolution operator)로 알려져 있습니다. 이 연산자는 여러가지 문맥에서 사용되며, 주로 다음과 같은 용도로 사용됩니다:

1. **네임스페이스 지정**: 네임스페이스 안에 있는 특정 심볼(변수, 함수, 클래스 등)에 접근할 때 사용됩니다.

   ```
   cppCopy code
   std::cout << "Hello, World!" << std::endl;
   ```

   여기서 `std::cout`와 `std::endl`은 `std` 네임스페이스 안의 `cout`과 `endl`을 나타냅니다.

2. **클래스의 정적 멤버나 메서드에 접근**: 정적 멤버 변수나 메서드에 접근할 때 사용됩니다.

   ```
   cppCopy codeclass MyClass {
   public:
       static int staticVar;
   };
   
   int MyClass::staticVar = 10;  // 클래스 외부에서 정적 멤버 변수 초기화
   ```

3. **클래스 외부에서 멤버 함수 구현**: 클래스 정의 외부에서 클래스의 멤버 함수를 구현할 때 사용됩니다.

   ```
   cppCopy codeclass MyClass {
   public:
       void myFunction();
   };
   
   void MyClass::myFunction() {  // 클래스 외부에서 멤버 함수 구현
       // 함수 본문
   }
   ```

4. **전역 범위 지정**: 만약 지역변수가 전역변수와 동일한 이름을 가질 경우, 전역변수에 접근하기 위해 `::`를 사용할 수 있습니다.

   ```
   cppCopy codeint x = 10;
   
   int main() {
       int x = 20;  // 지역 변수
       ::x = 30;    // 전역 변수 x에 접근
       return 0;
   }
   ```

이와 같이 `::` 연산자는 C++의 다양한 문맥에서 "어떤 범위의" 특정 심볼을 지칭하려고 할 때 사용됩니다.





## vector



`std::vector<std::vector<int>> adjList;`는 2차원의 동적 배열로 생각할 수 있습니다. 기본적으로 이것은 `std::vector`의 `std::vector`입니다.

보다 구체적으로 설명하면:

1. **`std::vector<int>`**: 정수의 동적 배열입니다. 크기를 미리 지정할 필요 없이 요소를 추가하거나 제거할 수 있습니다.
2. **`std::vector<std::vector<int>>`**: `std::vector<int>`의 동적 배열입니다. 이것은 기본적으로 2차원 배열과 비슷한 구조를 가지지만, 각 "행"의 길이가 다를 수 있으며, 동적으로 크기가 조절될 수 있습니다.

예시를 들면:

```c++
std::vector<std::vector<int>> matrix;

matrix.push_back({1, 2, 3});  // 첫 번째 "행" 추가
matrix.push_back({4, 5});     // 두 번째 "행" 추가 (길이가 다름에 주목)
matrix.push_back({6, 7, 8, 9}); // 세 번째 "행" 추가

std::cout << matrix[1][1];  // 출력: 5
```

이 구조는 그래프의 인접 리스트를 표현할 때 흔히 사용됩니다. 각 "행"은 그래프의 각 정점을 나타내고, 해당 "행"의 `std::vector<int>`는 그 정점과 인접한 다른 정점들의 목록을 나타냅니다.





## std

1. **`std`**:
   - `std`는 C++ 표준 라이브러리의 네임스페이스(namespace)입니다.
   - C++ 표준 라이브러리에는 여러 유용한 데이터 구조, 알고리즘, 함수 등이 포함되어 있습니다. 이러한 기능들은 `std`라는 네임스페이스 안에 정의되어 있어, 사용할 때 `std::`를 접두어로 붙여서 사용합니다.
   - 예를 들어, `cout`, `cin`, `vector`, `string` 등 많은 C++ 표준 라이브러리 구성요소들은 `std` 네임스페이스에 속해 있습니다.
2. **`vector`**:
   - `std::vector`는 C++ 표준 라이브러리의 동적 배열(dynamic array) 구현입니다.
   - 배열과 유사하게 원소들을 연속된 메모리 공간에 저장하지만, 크기가 고정되어 있지 않고 동적으로 크기가 변경될 수 있습니다.
   - 요소를 추가하거나 삭제할 때 자동으로 메모리를 관리합니다.

## push_back

1. **`push_back`**:

   - `push_back`은 `std::vector`의 멤버 함수로, 벡터의 끝에 새로운 요소를 추가하는데 사용됩니다.

   - 이 함수를 사용하여 `std::vector`에 요소를 추가하면, 필요한 경우 `std::vector`는 자동으로 크기를 늘려서 더 많은 요소를 저장할 수 있도록 메모리를 재할당합니다.

   - 예:

     ```c++
     std::vector<int> vec;
     vec.push_back(5);  // 벡터에 5 추가
     vec.push_back(10); // 벡터에 10 추가
     ```

간단히 요약하면, `std`는 C++의 표준 라이브러리 네임스페이스, `vector`는 동적 배열 구현, 그리고 `push_back`은 그 동적 배열에 요소를 추가하는 함수입니다.



## 자료구조 종류

C++에서는 표준 라이브러리(STL, Standard Template Library)를 통해 다양한 자료 구조를 제공합니다. 이 자료 구조들은 데이터를 효율적으로 저장하고, 접근하고, 조작하기 위해 설계되었습니다. 주요한 자료 구조들은 다음과 같습니다:

1. **컨테이너 시퀀스**:
   - `std::array` : 고정 크기의 배열
   - `std::vector` : 동적 배열
   - `std::deque` : 양쪽 끝에서 원소를 추가하거나 삭제할 수 있는 덱(deck)
   - `std::forward_list` : 단방향 연결 리스트
   - `std::list` : 양방향 연결 리스트
2. **연관 컨테이너**:
   - `std::set` : 중복을 허용하지 않는 정렬된 집합
   - `std::multiset` : 중복을 허용하는 정렬된 집합
   - `std::map` : 키와 값의 쌍을 저장하는 중복을 허용하지 않는 정렬된 맵
   - `std::multimap` : 키와 값의 쌍을 저장하는 중복을 허용하는 정렬된 맵
   - `std::unordered_set` : 해시를 기반으로 중복을 허용하지 않는 집합
   - `std::unordered_multiset` : 해시를 기반으로 중복을 허용하는 집합
   - `std::unordered_map` : 해시를 기반으로 하는 맵
   - `std::unordered_multimap` : 해시를 기반으로 중복을 허용하는 맵
3. **컨테이너 어댑터**:
   - `std::stack` : 스택
   - `std::queue` : 큐
   - `std::priority_queue` : 우선순위 큐 (보통 힙 구조를 기반으로 구현됩니다.)
4. **특수 목적 컨테이너**:
   - `std::bitset` : 고정된 크기의 비트 집합
   - `std::valarray` : 수치 연산 최적화를 위한 배열

이 외에도 C++ 표준 라이브러리는 다양한 알고리즘, 반복자, 함수 객체, 할당자 등을 제공하며, 이를 통해 다양한 문제를 효율적으로 해결할 수 있습니다.