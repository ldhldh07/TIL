# Django

## 사용자 인증 및 권한

### The Django authentication system

Django authentication system(인증 시스템)은 인증(Authentication)과 권한(Authorization) 부여를 함께 제공(처리)하며, 이러한 기능이 어느 정도 결합되어 일반적으로 인증 시스템이라고 함

인증 시스템이라는 단어 안에 권한도 들어있음

필수 구성은 settings.py에 이미 포함되어 있으며 INSTALLED_APPS에서 확인 가능

- `django.contrib.auth`

`Authentication(인증)`

- 신원 확인
- 사용자가 자신이 누구인지 확인하는 것

`Authorization(권한, 허가)`

- 권한 부여
- 인증된 사용자가 수행할 수 있는 작업을 결정

- admin, staff, 일반 유저

이 둘을 합쳐서 인증 시스템이라고 한다

accounts라는 다른 앱을 만들어서 처리함

#### 사전 설정

##### 두번째 app accounts 생성 및 등록

`python manage.py startapp accounts`

settings.py의 INSTALLED_APPS에 `'accounts',`추가

```python
INSTALLED_APPS = [
    'articles',
    'accounts',  # 추가
    'django_extensions',
    'bootstrap5',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```

auth와 관련한 경로나 키워드들을 Django 내부적으로 accounts라는 이름으로 사용하고 있기 때문에 되도록 accounts로 지정하는 것을 권장

다른 이름으로 설정해도 되지만 나중에 추가 설정을 해야할 일들이 생김

##### url 분리 및 매핑

accounts/urls.py

```python
from django.urls import path
from . import views

app_name = 'accounts'
# 빈 리스트라도 넣어놔야 한다
urlpatterns = [

]
```

crud/settings.py

```python
from django.contrib import admin
from django.urls import path, include


urlpatterns = [
    path('admin/', admin.site.urls),
    path('articles/', include('articles.urls')),
    path('accounts/', include('accounts.urls')),
]

```

#### Substituting a custom User model

Custom User Model로 대체하기

기본 User model을 필수적으로 custom User model로 대체하는 이유 이해하기

Django는 기본적인 인증 시스템과 여러 가지 필드가 포함된 User Model을 제공, 대부분의 개발 환경에서 기본 User Model을 Custom User Model로 대체함

admin도 User였다

개발자들이 작성한 일부 프로젝트에서는 django에서 제공하는 built-in User model의 기본 인증 요구사항이 적절하지 않을 수 있음

- 예를 들면 내 서비스에서 회원 가입시  username 대신 email을 식별 값으로 사용하는 것이 더 적합한 사이트인 경우는 django의 User model이 기본적으로 username를 식별값으로 사용하기 때문에 기존 User model을 수정해야하나 쉽지 않은 작업이기 때문

그래서 Django는 현재 프로젝트에서 나타낼 User를 참조하는 `AUTH_USER_MODEL` 설정 값을 제공하여 default user model을 재정의(override)할 수 있도록 함

#### User()

AbstractUser를 상속받음

얘만 상속 받으면 끝남

커스텀을 지금 진행할 필요는 없는데 

미리 클래스 작성은 해놔야함 

나중에 수정하긴 어려워서 미리 대체해놓고 시작

그렇게 하면 장고가 제공하는 기본 클래스와 동일하게 이용할 수 있다

#### AUTH_USER_MODEL

프로젝트에서 User를 나타낼 때 사용하는 모델

현재 이 프로젝트에서 어떤 유저모델을 사용하고 있는지 나타냄

프로젝트가 시작되는 동안 (모델을 만들고 마이그레이션 한 후) 변경할 수 없음

프로젝트 시작 시 설정하기 위한 것이며, 참조하는 모델은 첫번째 마이그레이션에서 사용할 수 있어야 함

- 즉, 첫번째 마이그레이션 전에 확정지어야 하는 값

다음과 같은 기본값

`settings.py`

```python
AUTH_USER_MODEL = 'auth.User'
```

auth라는 앱의 user 클래스를 사용한다

auth는 쟝고의 

##### [참고] settings의 로드 구조

AUTH_USER_MODEL은 settings.py에 보이지 않는데 어디에 기본 값이 작성되어 있는 걸까?

- 우리가 작성하는 settings.py는 사실 global_settings.py를 상속받아 재정의하는 파일
- https://github.com/django/django/blob/main/django/conf/global_settings.py

#### How to substituting a custom User model

custom User model로 대체하기

외우기 어려울 경우 공식문서보기

https://docs.djangoproject.com/en/4.1/topics/auth/customizing/#substituting-a-custom-user-model

#### ##### 대체하기

###### AbstractUser를 상속받는 커스텀 User 클래스 작성

기존 User 클래스도 AbstractUser를 상속받기 때문에 커스텀 User 클래스도 완전히 같은 모습을 가지게 됨

https://github.com/django/django/blob/main/django/contrib/auth/models.py#L405

https://github.com/django/django/blob/main/django/contrib/auth/models.py#L334

accounts/models.py

```python
from django.db import models
from django.contrib.auth.models import AbstractUser

# Create your models here.
class User(AbstractUser):
    pass
```

###### Django 프로젝트에서 User를 나타내는데 사용하는 모델을 방금 생성한 커스텀 User 모델로 지정

settings.py

```python
...


AUTH_USER_MODEL ='accounts.User'
```

원래 상속받아 안보이는 `AUTH_USER_MODEL = 'auth.User'`가 있음

###### admin.py에 커스텀 User 모델을 등록

- 기본 User모델이 아니기 때문에 등록하지 않으면 admin site에 출력되지 않음

`from django.contrib.auth.admin import UserAdmin`

`from .models import User`

두개 추가하고

`admin.site.register(User, UserAdmin)` 밑에 작성

accounts/admin.py

```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import User
# Register your models here.

admin.site.register(User, UserAdmin)
```

##### [참고] AbstactUser

관리자 권한과 함께 완전한 기능을 가지고 있는 User model을 구현하는 추상 기본클래스

###### Abstract base classes(추상 기본 클래스)

몇 가지 공통 정보를 여러 다른 모델에 넣을 때 사용하는 클래스

데이터베이스 테이블을 만드는 데 사용되지 않으며, 대신 다른 모델의 기본 클래스로 사용되는 경우 해당 필드가 하위 클래스의 필드에 추가 됨

테이블 안만들고 다른 클래스 생성하기 위한 도장 역할, 찍어냄

상속용

https://docs.python.org/3/library/abc.html

##### 프로젝트 중간에 AUTH_USER_MODEL 변경하기

모델 관계에 영향을 미치기 때문에 훨씬 더 어려운 작업이 필요

- 예를 들면 변경사항이 자동으로 수행될 수 없기 때문에 DB 스키마를 직접 수정하고, 이전 사용자 테이블에서 데이터를 이동하고, 일부 마이그레이션을 수동으로 다시 적용해야 함

결론은 중간 변경은 권장하지 않음

프로젝트 처음에 진행하기

###### 데이터베이스 초기화

수업 진행을 위한 데이터베이스 초기화 후 마이그레이션 (프로젝트 중간일 경우)

1. migrations 파일 삭제
   - migrations 폴더 및 `__init__.py`는 삭제하지 않음
   - 번호가 붙은 파일만 삭제
2. db.sqlite3 삭제
3. migrations 진행
   - makemigrations
   - migrate

```bash
$ python manage.py makemigrations
Migrations for 'articles':
  articles\migrations\0001_initial.py
    - Create model Article
Migrations for 'accounts':
  accounts\migrations\0001_initial.py
    - Create model User
```

이전에는 하나만 떴는데 이제 accounts도 뜸

`accounts/migrations/0001.initial.py`

처음인데도 dependencies가 있음

필드가 많음

AbstractsUser에서 나온 설정값들

```bash
$ python manage.py migrate
Operations to perform:
  Apply all migrations: accounts, admin, articles, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0001_initial... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying accounts.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying articles.0001_initial... OK
  Applying sessions.0001_initial... OK
```

`db.sqlite3`

accounts_user 생김

대체하기전에는 auth_user 이렇게 뜨던거

##### 반드시 User 모델을 대체해야 할까?

Django는 새 프로젝트를 시작하는 경우 비록 기본 User 모델이 충분하더라도 커스텀 User 모델을 설정하는 것을 강력하게 권장(highly recommended)

커스텀 User 모델은 기본 User 모델과 동일하게 작동하면서도 필요한 경우 나중에 맞춤 설정할 수 있기 때문

- 단, User 모델 대체 작업은 프로젝트의 모든 migrations 혹은 첫 migrate를 실행하기 전에 이 작업을 마쳐야 함
- 이미 진행중일때는 데이터베이스 초기화하고 진행

### HTTP Cookies

#### HTTP 

Hyper Text Transfer Protocol

HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜(규칙, 규약) 

웹(WWW)에서 이루어지는 모든 데이터 교환의 기초 . 

클라이언트 - 서버 프로토콜이라고도 부름

##### 요청과 응답

`요청(request)`: 클라이언트(브라우저)에 의해 전송되는 메시지

`응답(response)`: 서버에서 응답으로 전송되는 메시지

##### HTTP 특징 

1. 비 연결 지향(connectionless) 
   -  서버 요청에 대한 응답을 보낸 후 연결을 끊음
     - 예를 들어 우리가 네이버 메인 페이지를 보고 있을 때 우리는 네이버 서버와 연결되어 있는 것이 아님 
     - 네이버 서버는 우리에게 메인 페이지를 응답하고 연결을 끊은 것
2. 무상태(stateless) 
   - 연결을 끊는 순간 클라이언트와 서버 간의 통신이 끝나며 상태 정보가 유지 않음 
   - 클라이언트와 서버가 주고받는 메시지들은 서로 완전히 독립적
   - 이런 상황에서 로그인을 하면 유지되지 못해야 함 -> 어떻게 다음에 유지가 될 수 있나

##### 어떻게 로그인 상태를 유지할까?

그런데 우리가 로그인을 하고 웹 사이트를 사용할 때 페이지를 이동해도 로그인 상태”가 유지됨

서버와 클라이언트 간 지속적인 상태 유지를 위해 "쿠키와 세션"이 존""

#### 쿠키(Cookie)

HTTP는 상태가 있는 세션을 만들도록 해 줌

세션 : 상태가 있는 쿠키

##### 개념

원리

- 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다. 

- 사용자가 웹사이트를 방문할 경우 해당 웹사이트의 서버를 통해 사용자의 컴퓨터(브라우저)에 설치되는 작은 기록 정보 파일 

  1. 브라우저(클라이언트)는 쿠키를 로컬에 KEY-VALUE의 데이터 형식으로 저장 

  2. 이렇게 쿠키를 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 쿠키를 함께 전송

- 우리가 서버에 `요청`을 보내면 `응답` 안에 쿠키가 있음

쿠키는 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 때 주로 사용됨

- 이를 이용해 사용자의 로그인 상태를 유지할 수 있음 
- 상태가 없는(stateless) HTTP 프로토콜에서 상태 정보를 기억 시켜 주기 때문

매 요청마다 로그인된 상태라는 것을 알림 

즉, 웹 페이지에 접속하면 웹 페이지를 응답한 서버로부터 쿠키를 받아 브라우저에 저장하고 클라이언트가 같은 서버에 재요청 시마다 요청과 함께 저장해 두었던 쿠키도 함께 전송

##### 쿠키 사용 예시

web browser <-> web server

1. The browser requests a web page 
2. The server sends the page and the cookie 
3. The browser requests another page from the same server Web browser

##### 쿠키 사용 목적 

###### 세션 관리 (Session management) 

로그인, 아이디 자동완성, 공지 하루 안 보기, 팝업 체크, 장바구니 등의 정보 관리 

###### 개인화 (Personalization)

사용자 선호, 테마 등의 설정 GE. 

###### 트래킹 (Tracking) 

사용자 행동을 기록 및 분석

##### 쿠키 장바구니 예시

장바구니에 상품 담기

개발자 도구 -> Network탭 무슨 쿠키를 보내는지 알수 있음

어플리케이션의 cookies를 보면 거기서 쿠키 지울 수 있음

##### 세션(Session)

사이트와 특정 브라우저 사이의 "state(상태)" 를 유지시키는 것 

쿠키 세션이라고도 함

클라이언트가 서버에 접속하면 서버가 특정 session id를 발급하고, 클라이언트는 session id를 쿠키에 저장 

- 클라이언트가 다시 동일한 서버에 접속하면 요청과 함께 쿠키(session id가 저장된)를 서버에 전달
- 쿠키는 요청 때마다 서버에 함께 전송 되므로 서버에서 session id를 확인해 알맞은 로직을 처리

session id는 세션을 구별하기 위해 필요하며, 쿠키에는 session id만 저장

핵심 데이터는 서버에 저장 그래서 키만 계속 제출

###### 세션을 이용한 gitlab 예시

https://lab.ssafy.com/users/sign_in?auto_sign_in=false 

Project ssafy가 아닌 lab ssaft에서 로그인해야함

개발자 도구 - 애플리케이션 탭

Gitlab 서버로부터 받아 저장된 session 쿠키 확인

쿠키에는 유효기간이 존재함

근데 유효기간이 안써있고 세션이라고 써있는 것이 있음

##### 쿠키 Lifetime (수명) 

1. Session cookie 

   현재 세션(current session)이 종료되면 삭제됨 

   브라우저 종료와 함께 세션이 삭제됨 

2. Persistent cookies 

   Expires 속성에 지정된 날짜 혹은 Max-Age 속성에 지정된 기간이 지나면 삭제됨

##### Session in Django 

세션의 복잡한 원리 django가 해줌

Django는 `database-backed sessions` 저장 방식을 기본 값으로 사용

- session 정보는 Django DB의 `django_session` 테이블에 저장

  - 스키마 - key data expired_date
  - 키만 브라우저에 줌
  - 실제 중요한 데이터는 테이블에 가지고 있음

- 설정을 통해 다른 저장방식으로 변경 가능 

  https://docs.djangoproject.com/en/3.2/topics/http/sessions/ 

Django는 특정 `session id`를 포함하는 쿠키를 사용해서 각각의 브라우저와 사이트가 연결된 session을 알아냄

Django는 우리가 session 메커니즘(복잡한 동작원리)에 대부분을 생각하지 않게끔 많은 도움을 줌

### Authentication in Web requests 

Django가 제공하는 인증 관련 `built-in forms` 익히기

로그인, 가입, 연결 이런거 이미 있는걸 사용

직접 안쓰고 빌트인으로 대부분 씀

https://docs.djangoproject.com/en/3.2/topics/auth/default/#module-django.contrib.auth.forms

#### Login

로그인은 Session을 Create하는 과정

##### AuthenticationForm

로그인을 위한 built-in form

- 로그인 하고자 하는 사용자 정보를 입력 받음 
- 기본적으로 username과 password를 받아 데이터가 유효한지 검증

request를 첫번째 인자로 취함

https://github.com/django/django/blob/main/django/contrib/auth/forms.py#L174

##### login() 

login(request, user, backend=None)

입력된 데이터를 판단해서 현재 세션에 데이터 입력하는 과정

인증된 사용자를 로그인 시키는 로직으로 view 함수에서 사용됨 

현재 세션에 연결하려는 인증된 사용자가 있는 경우 사용

세션이 만들어지고 세션을 발급받아서 우리 브라우저에 저장

HttpRequest 객체와 User 객체가 필요 (요청 객체와 유저 객체)

###### 로그인 로직 작성

view 함수 login과의 충돌을 방지하기 위해 import한 login 함수 이름을 auth_login으로 변경해서 사용

##### get_user() 

AuthenticationForm의 인스턴스 메서드 

유효성 검사를 통과했을 경위 로그인 한 사용자 객체를 반환

- 통과 못하면 리턴 안해줌

https://github.com/django/django/blob/main/django/contrib/auth/forms.py#L244

##### 로그인 페이지 작성

urls.py에 `  path('login/', views.login, name='login'),` 추가

`accounts/urls.py`

```python
from django.urls import path
from . import views


app_name = 'accounts'
urlpatterns = [
    path('login/', views.login, name='login'),
]
```

`views.py`에 로그인 함수 더해주는데 new-create 처럼 메소드로 구분해서 두개 역할 한번에 가능

두개로 나눔

``` 
def login(request):
    if request.method == 'POST':
        pass
    else:
```



built-in form을 import 해줌

- 따로 만들 필요 없음
- `from django.contrib.auth.forms import AuthenticationForm`

인스턴스를 만듬

- `form = AuthenticationForm()`

페이지에 렌더링

```py
    context = {
        'form' : form,
    }
    return render(request, 'accounts/login.html', context)
```

- indent 주의

결과 accounts/views.py

``` python
from django.shortcuts import render
from django.contrib.auth.forms import AuthenticationForm # import

# Create your views here.
def login(request):
    if request.method == 'POST':
        pass
    else:
        form = AuthenticationForm() # 인스턴스를 만듦
    # 인덴트 주의
    context = {
        'form' : form,
    }
    return render(request, 'accounts/login.html', context)
```

accounts/templates/accounts/login.html 만듬 

##### 로그인 로직 작성

이때 서버에 틀어서 /accounts/login/ 들어가면 나오는 것이

AuthenticationForm

https://github.com/django/django/blob/main/django/contrib/auth/forms.py#L174

모델폼이 아니라 폼임

데이터베이스 필드에 매핑되는 것이 아니라 데이터베이스의 다른 목적으로 쓰기 때문



이제 제출했을 때 해야할 것을 `if request.method == 'POST':`에 작성

`form = AuthenticationForm(request, request.POST)`추가해서 입력한것으로 인스턴스 만듬

유효성 검증

- 로그인- 세션을 받을 수 있는 도구
  - 기본 함수로 함 

- `from django.contrib.auth import login`로 함수 불러옴

불러오는 클래스에 `redirect` 추가

- `from django.shortcuts import render, redirect`

문제

1. login 함수가 두개가 되어버림, 기본 함수 불러오는 것 이름 바꿔줌

   `from django.contrib.auth import login as auth_login`

2. 유저정보 어디서 불러오는가

   폼 안에 들어있을 것 

   인증된 유저를 리턴해주는 인스턴스 메소드를 어센틱폼이 제공

   `auth_login(request, form.get_user())`

accounts/views.py 결과

```python
from django.shortcuts import render, redirect # redirect 추가
from django.contrib.auth.forms import AuthenticationForm # import
from django.contrib.auth import login as auth_login

# Create your views here.
def login(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, request.POST) # 첫인자 request
        if form.is_valid():
            # 로그인
            auth_login(request, form.get_user()) # 어센틱폼이 제공하는 인스턴스 메소드
            return redirect('articles:index')
    else:
        form = AuthenticationForm() # 인스턴스를 만듦
    # 인덴트 주의
    context = {
        'form' : form,
    }
    return render(request, 'accounts/login.html', context)
```



로그인 실제 됐는지 확인

- 개발자 도구의 어플리케어션 - 쿠키 확인  sessionid 있음

- DB의 django_session에도 세션이 생겼고 이건 위에 쿠키에 있는 벨류값과 같음

- 이렇게 쿠키는 매 요청마다 보냄

서버에 다 저장하면 부하가 오기 때문에 브라우저에 저장

base.html에 로그인 페이지 링크

- `<a href="{% url 'accounts:login' %}">Login</a>`

그 위에 유저 정보

- `{{ user }}`
- context로 받아오지도 않았는데 뜸

##### Authentication with User

###### 현재 로그인되어있는 유저 정보 출력하기

`{{ user }}`

context가 기본 context가 있음

어떻게 base 템플릿에서 context 데이터 없이 user 변수를 사용할 수 있는 걸까?

- settings.py의 `context processors` 설정 값 때문
  - django가 우리가 자주 쓸만한 것들 미리 로드해둔 것
  - `'django.contrib.auth.context_processors.auth',`
  - 이게 있어서 어떤 페이지에서도 `{{ user }}`를 쓸 수 있음

base.html

```django
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">  <title>Document</title>
</head>
<body>
  <div class="container">
    <h3>{{ user }}</h3>
    <a href="{% url 'accounts:login' %}">Login</a>
    {% block content %}
    {% endblock content %}
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
</body>
</html>

```

###### context processors

템플릿이 렌더링 될 때 호출 가능한 컨텍스트 데이터 목록 

작성된 컨텍스트 데이터는 기본적으로 템플릿에서 사용 가능한 변수로 포함됨

즉, django에서 자주 사용하는 데이터 목록을 미리 템플릿에 로드 해 둔 것

현재 user 변수를 담당하는 프로세서는 django.contrib.auth.context_processors.auth 

이외에 더 많은 Built-in template context processors들은 공식문서를 참고 

- https://docs.djangoproject.com/en/3.2/ref/templates/api/#built-in-template-context-processors
- 공식문서에서는 auth_user라고 하지만 우리는 커스텀 한 상태
- 로그인 안한 경우를 AnonymousUser라고 표현

```py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR, 'templates',],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

별도로 user라는 context를 작성해서 보내지 않도록 주의

###### django.contrib.auth.context_processors.auth

현재 로그인한 사용자를 나타내는 User 클래스의 인스턴스가 템플릿 변수 `{{ user }}`에 저장됨 

- 클라이언트가 로그안하지 않은 경우 `AnonymousUser` 클래스 의 인스턴스로 생성
- 로그인 상태면 admin라고 출력됨
- 비로그인 상태면 AnonymousUser라고 출력됨

#### Logout

로그아웃은 Session을 Delete하는 과정

유저를 삭제하는 것이 아닌 세션을 삭제하는것



쿠키와 세션 remind

서버-클라이언트

서버가 요청해서 클라이언트가 쿠키 받음

받은 쿠키를 브라우저에 저장

같은 서버에 재요청할때 저장해뒀던 쿠키를 같이 보낸다

##### logout()

logout(request) 

HttpRequest 객체를 인자로 받고 반환 값이 없음 

사용자가 로그인하지 않은 경우 오류를 발생시키지 않음 

다음 2가지 일을 처리한다. 

	1. 현재 요청에 대한 session data를 DB에서 삭제 
	2. 클라이언트의 쿠키에서도 sessionid를 삭제

- 이는 다른 사람이 동일한 웹 브라우저를 사용하여 로그인하고, 이전 사용자의 세션 데이터에 액세스하는 것을 방지하기 위함

##### 로그아웃 페이지 작성

urls.py 만들기

`  path('logout/', views.logout, name='logout'),` 추가

```python
from django.urls import path
from . import views


app_name = 'accounts'
urlpatterns = [
    path('login/', views.login, name='login'),
    path('logout/', views.logout, name='logout'),
]
```

views.py 함수 만들기

`from django.contrib.auth import logout as auth_logout`

함수 불러오고 이름 바꿔주기

accounts/views.py

```py
def logout(request):
    # 로그아웃
    auth_logout(request)
    return redirect('articles:index')
```

로그아웃 버튼 만들기

```django
    <form action="{% url 'accounts:logout' %}" method="POST">
      {% csrf_token %}
      <input type="submit" value="Logout">
    </form>
```



base.html 결과

```django
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">  <title>Document</title>
</head>
<body>
  <div class="container">
    <h3>{{ user }}</h3>
    <a href="{% url 'accounts:login' %}">Login</a>
    <form action="{% url 'accounts:logout' %}" method="POST">
      {% csrf_token %}
      <input type="submit" value="Logout">
    </form>
    {% block content %}
    {% endblock content %}
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
</body>
</html>

```

### Authentication with User

User Object와 User CRUD에 대한 이해

- 회원 가입, 회원 탈퇴, 회원정보 수정, 비밀번호 변경

#### 회원 가입

회원가입은 User를 Create하는 것이며 `UserCreationForm` built-in form을 사용

##### UserCreation Form

 주어진 username과 password로 권한이 없는 새 user를 생성하는 ModelForm

- 관리자(superuser)가 아닌 일반 유저
- 이건 저장이 되어야 하기 때문에 모델폼

3개의 필드를 가짐 

	1. username (from the user model)
	1. password1 

3. Password2
   - 패스워드 확인

https://github.com/django/django/blob/stable/3.2.x/django/contrib/auth/forms.py#L75

##### 회원가입 페이지 작성

###### signup url 추가

`  path('signup/', views.signup, name='signup'),`

ulrs.py

```python
from django.urls import path
from . import views


app_name = 'accounts'
urlpatterns = [
    path('login/', views.login, name='login'),
    path('logout/', views.logout, name='logout'),
    path('sighup/', views.sighup, name='sighup'),
]
```

###### view함수 

여기도 create처럼 두개 필요

빌트인 폼이라 이것도 가져와줘야 함

- `from django.contrib.auth.forms import AuthenticationForm, UserCreationForm # import`

```python
def signup(request):
    if request.method == 'POST':
        pass
    else:
```

메소드 조건해주고

`form = UserCreationForm()`불러온 함수를 써줌

```python
    context = {
        'form':form,
    }
    return render(request, 'account/sigup.html', context)
```

콘텍스트랑 렌더링

###### signup.html 만듬

views.py

```python
from django.shortcuts import render, redirect
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm # import
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout

# Create your views here.
def login(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, request.POST)
        if form.is_valid():
            auth_login(request, form.get_user())
            return redirect('articles:index')
    else:
        form = AuthenticationForm() 
    context = {
        'form' : form,
    }
    return render(request, 'accounts/login.html', context)

def logout(request):
    auth_logout(request)
    return redirect('articles:index')


def signup(request):
    if request.method == 'POST':
        pass
    else:
        # 위에서 빌드힌 함수 불러와줘야함
        form = UserCreationForm()
    context = {
        'form':form,
    }
    return render(request, 'accounts/signup.html', context)
```

signup.html 만들기

login 가져와서 씀

action의 url이랑 텍스트 내용만 바꿔줌

`signup.html`

```django
{% extends 'base.html' %}

{% block content %}
<h1>SIGNUP</h1>
<form action="{% url 'accounts:signup' %}" method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <input type="submit">
</form>

{% endblock content %}
```

서버 켜서 url들어가면 로그인 빌트인 폼 나옴

language_code에 따라 한글로 됨

###### base.html에 사인업 링크 추가

`<a href="{% url 'accounts:signup' %}">Signup</a>`

base.html

```django
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">  <title>Document</title>
</head>
<body>
  <div class="container">
    <h3>{{ user }}</h3>
    <a href="{% url 'accounts:login' %}">Login</a>
    <form action="{% url 'accounts:logout' %}" method="POST">
      {% csrf_token %}
      <input type="submit" value="Logout">
    </form>
    <a href="{% url 'accounts:signup' %}">Signup</a>
    {% block content %}
    {% endblock content %}
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
</body>
</html>

```

##### 회원가입 로직 작성

###### 다시 view로 가서 post로 받아올때의 함수 만들기

입력된 것 인스턴스 함수로 불러옴

- `form = UserCreationForm(request.POST)`

유효성 검사

```python
if form.is_valid():
    form.save()
    return redirect('articles:index')

```

통과되면 저장하고 리다이렉트

통과되지 못하면 인덴트 조절로 인해 밑에 render하는 곳으로 감 

views.py

```python
from django.shortcuts import render, redirect
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm # import
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout

# Create your views here.
def login(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, request.POST)
        if form.is_valid():
            auth_login(request, form.get_user())
            return redirect('articles:index')
    else:
        form = AuthenticationForm()
    context = {
        'form' : form,
    }
    return render(request, 'accounts/login.html', context)

def logout(request):
    auth_logout(request)
    return redirect('articles:index')


def signup(request):
    if request.method == 'POST':
        # 입력된 것 인스턴스 함수로 불러옴
        form = UserCreationForm(request.POST)
        # 유효성 검사
        if form.is_valid():
            # 통과되면 저장하고 메이페이지로 리다이렉트
            form.save()
            return redirect('articles:index')
            # 통과되지 못하면 아래의 인덴트 맞춘 rendering으로 넘어감
    else:
        # 위에서 빌드힌 함수 불러와줘야함
        form = UserCreationForm()
    context = {
        'form':form,
    }
    return render(request, 'accounts/signup.html', context)
```

##### 회원가입 진행 후 에러 페이지를 확인 

이상태로 가입하면 에러 뜸

`AttributeError at /accounts/signup/`

`Manager isn't available; 'auth.User' has been swapped for 'accounts.User'`

모델폼이기 때문에 기본 유저 모델을 쓰도록 되어있는것

회원가입에 사용하는 UserCreationForm이 우리가 대체한 커스텀 유저 모델이 아 닌 기존 유저 모델로 인해 작성된 클래스이기 때문 

https://github.com/django/django/blob/main/django/contrib/auth/forms.py#L106

이 안에 model = User가 있는데 여기 있는 User를 우리가 안쓰고 있음

유저 모델 바꿨으니까 못쓴다는 말

이는 https://github.com/django/django/blob/stable/3.2.x/django/contrib/auth/forms.py#L75

여기서 활용가능

이걸 해결하려면 우리가 저걸 그대로 받아서 덮어씌우고 바꾸면 됨

#### Custom user & Built-in auth forms

- Custom user와 기존 Built-in auth forms 간의 관계

- Custom user로 인한 Built-in auth forms 변경

  

기존의 유저모델을 사용하던 모델폼들이 있음

그중에 하나다 UserCreationForm

자동으로 스왑이 안됨

##### AbstractBaseUser 의 모든 subclass와 호환되는 forms

아래 Form 클래스는 User 모델을 대체하더라도 커스텀하지 않아도 사용 가능

1. `AuthenticationForm `
2. `SetPasswordForm `
3. `PasswordChangeForm`
4. `AdminPasswordChange Form`

기존 User 모델을 참조하는 Form이 아니기 때문

##### 커스텀 유저 모델을 사용하려면 다시 작성하거나 확장해야 하는 forms 

1. UserCreationForm 
   - 회원가입
2. UserChangeForm 
   - 회원 정보 수정

두 form 모두 `class Meta: model = User`가 등록된 form이기 때문에 반드시 커스텀(확장)해야 함

다시 작성까지는 안해도 되고 상속받아서 확장하면 됨

##### UserCreationForm() 커스텀하기

###### accounts앱에 forms.py 만들기 

거기에 빌트인 폼 가져와줌

`from django.contrib.auth.forms import UserCreationForm`

```python
from django.contrib.auth.forms import UserCreationForm

class CustomUserCreationForm(UserCreationForm):

    class Meta(UserCreationForm.Meta):
```

###### 우리가 만든 유저 모델 넣기

`from .models import User`로 가져오고 `model = User`할수도 있는데 이렇게 직접 참조하는건 장고에서 권장 X

간접적으로 현재 프로젝트에서 사용하는 유저모델을 반환하는 함수 쓰는걸 권장

`from django.contrib.auth import get_user_model`

`model = get_user_model()`

###### UserChangeForm 아직 안배웠지만 미리 상속으로 만들어놓기

`from django.contrib.auth.forms import UserCreationForm, UserChangeForm`에 `UserChangeForm`추가하고

```python
class CustomUserChangeForm(UserChangeForm):

    class Meta(UserChangeForm.Meta):
        model = get_user_model()
```

유저모델 상속받아줌



`forms.py` 결과

```python
from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserCreationForm, UserChangeForm

class CustomUserCreationForm(UserCreationForm):

    class Meta(UserCreationForm.Meta):
        model = get_user_model()

class CustomUserChangeForm(UserChangeForm):

    class Meta(UserChangeForm.Meta):
        model = get_user_model()
```

###### get_user_model()

"현재 프로젝트에서 활성화된 사용자 모델(active user model)"을 반환

활성화된 = 지금 쓰고있는

직접 참조하지 않는 이유

- 예를 들어 기존 User 모델이 아닌 User 모델을 커스텀 한 상황에서는 커스텀 User 모델을 자동으로 반환해주기 때문
- 이름이 다를수도 있고 그런데 활성화된 모델을 하면 됨

Django는 User 클래스를 직접 참조하는 대신 get_user_model()을 사용해 참조해야 한다고 강조하고 있음 

User model 참조에 대한 자세한 내용은 추후 모델 관계 수업에서 다룰 예정

###### 모델폼에 이메일도 입력할 수 있게 만들기

빌트인폼 공식 문서 보면 meta에 필드로 아이디가 있음

`fields = ("username")`

(패스워드 1,2가 있는데 이건 저장 안되어서 별개로 있음)

이처럼 커스텀에 더 추가해줌

`fields = UserCreationForm.Meta.fields + ('email',)`

추가해주면 이메일 입력칸도 나옴

이건 optional한거라 반드시 입력하지는 않아도 됨

넣을수 있는 필드는 db에서 보거나 migration파일 보면 거기도 나와있음

공식문서: https://docs.djangoproject.com/en/4.1/ref/contrib/auth/

###### CustomUserCreationForm()으로 대체하기

views.py 에 UserCreationForm이라 써놓은거 수정

`from django.contrib.auth.forms import AuthenticationForm, UserCreationForm`

에서 `UserCreationForm` 지워줌

그리고 우리가 직접 만든 걸 import

- `from .forms import CustomUserCreationForm`

그리고 signup 함수에서도 두개 수정

`form = UserCreationForm(request.POST)`

-> `form = CustomUserCreationForm(request.POST)`

`form = UserCreationForm()`

-> `form = CustomUserCreationForm()`

views.py

```python
from django.shortcuts import render, redirect
from django.contrib.auth.forms import AuthenticationForm # import
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
from .forms import CustomUserCreationForm

...

def signup(request):
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST) # 만든 유저 모델
        if form.is_valid():
            form.save()
            return redirect('articles:index')
    else:
        form = CustomUserCreationForm() # 만든 유저 모델
    context = {
        'form':form,
    }
    return render(request, 'accounts/signup.html', context)
```

##### 회원가입하고 바로 로그인 하게 하기

views의 signup함수에 추가

회원가입 `save()`한 이후와 `redirect`하기 전에 `auth_login()` 넣어줌

auth_login에는 유저 객체가 있어야 하는데 어디서 가져올까

login에서는 get_user() 썼지만 이건 AuthenticationForm에서 제공하는 메소드임

`user = form.save()` 해서 유저 정보를 인스턴스 객체로 가져오고 auth_login()에 request, user 넣어줌

깃험 장고 공식문서 forms.py보니까 save()는 user를 리턴함

```python
            user = form.save()  # user = cnrk
            auth_login(request, user)
```

accounts/views.py

```python
from django.shortcuts import render, redirect # redirect 추가
from django.contrib.auth.forms import AuthenticationForm # import
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
from .forms import CustomUserCreationForm


def signup(request):
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST) 
        if form.is_valid():
            user = form.save() # user = 추가
            # 회원가입하고 바로 로그인 하려면 이 단계에서 로그인 실행
            # user 입력은 form.save()에서 인스턴스 가져와서 넣어줌
            auth_login(request, user)
            return redirect('articles:index')
    else:
        form = CustomUserCreationForm()
    context = {
        'form':form,
    }
    return render(request, 'accounts/signup.html', context)
```

###### [참고] UserCreationForm의 save 메서드 

user를 반환하는 것을 확인

https://github.com/django/django/blob/main/django/contrib/auth/forms.py#L139 

```python
    def save(self, commit=True):
        user = super().save(commit=False)
        user.set_password(self.cleaned_data["password1"])
        if commit:
            user.save()
        return user
```

#### 회원 탈퇴

회원 탈퇴하는 것은 DB에서 유저를 Delete하는 것과 같음

##### 회원 탈퇴 로직 작성

###### url 작성

`  path('delete/', views.delete, name='delete'),`

accounts/urls.py

###### views 함수 작성

`request.user`라는 객체 안에 정보 들어있음 이걸 `.delete()`해줌

```python
def delete(request):
    request.user.delete()
    return redirect('articles:index')
```

###### base.html에 링크만들기

###### [참고] 탈퇴 하면서 해당 유저의 세션 정보도 함께 지우고 싶을 경우

탈퇴해도 쿠키나 DB의 세션에 세션은 남아있음 죽은 세션이라 의미없긴 하지만 남아있음

그래서 로그아웃하겠다

"탈퇴(1) 후 로그아웃(2)"의 순서가 바뀌면 안됨

먼저 로그아웃 해버리면 해당 요청 객체 정보가 없어지기 때문에 탈퇴에 필요한 정보 또한 없어지기 때문

views.py

```python
def delete(request):
    # request.user 객체에 유저 정보 있음
    request.user.delete()
    auth_logout(request)
    return redirect('articles:index')
```

#### 회원정보 수정

회원정보 수정은 User를 Update하는 것이며 UserChangeForm built-in form을 사용

이미 선커스텀해둠

##### UserChangeForm 

사용자의 정보 및 권한을 변경하기 위해 `admin 인터페이스`에서 사용되는 ModelForm

- 회원정보 직접적으로 사용하니 ModelForm
- 내부적으로 admin 페이지에서 쓴다

admin 페이지에서 계정정보 들어가면 나오는게 UserChangeForm

- 이걸 사용자들에게 출력해주는 것

UserChangeForm 또한 ModelForm이기 때문에 instance 인자로 기존 user 데이터 정보를 받는 구조 또한 동일함

- 이전 모델폼 배울때도 instance인자 있으면 update

이미 이전에 CustomUserChangeForm으로 확장했기 때문에 CustomUserChangeForm을 사용하기

##### 회원정보 수정 페이지 작성

###### url 작성

`  path('update/', views.update, name='update'),`

###### views함수 작성

수정하기 위해서는 view함수 원래 두개 필요

메쏘드 조건으로 하나로 가능

`from .forms import CustomUserCreationForm, CustomUserChangeForm`

커스텀한 폼 가져오기

```python
def update(request):
    if request.method == 'POST':
        pass
    else: # 유저 정보는 request 객체에 있다
        form = CustomUserChangeForm(instance=request.user)
    context = {
        'form' : form
    }
    return render(request, 'accounts/update.html', context)
```

메소드가 POST가 아닐때부터 작성 -> 이게 원래의 edit

###### update.html 작성

signup 그대로 가져오면 됨

```django
{% extends 'base.html' %}

{% block content %}
<h1>회원정보 수정</h1>
<form action="{% url 'accounts:update' %}" method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <input type="submit">
</form>

{% endblock content %}
```

##### UserChangeForm 사용시 문제점

일반 사용자가 접근해서는 안 될 정보들(fields)까지 모두 수정이 가능해짐

- admin 인터페이스에서 사용되는 ModelForm이기 때문

따라서 UserChangeForm을 상속받아 작성해 두었던 서브 클래스 

CustomUserChangeForm 에서 접근 가능한 필드를 조정해야 함

##### CustomUserChangeForm fields 재정의

이것도 아까처럼 forms.py에서 커스텀폼에서 field바꿔주면 됨

이번엔 줄여줘야 하니깐 아예 재구성 해버림

`fields = ('email', 'first_name', 'last_name')`

forms.py

```python
from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserCreationForm, UserChangeForm

class CustomUserCreationForm(UserCreationForm):

    class Meta(UserCreationForm.Meta):
        model = get_user_model()
        fields = UserCreationForm.Meta.fields + ('email',)

class CustomUserChangeForm(UserChangeForm):

    class Meta(UserChangeForm.Meta):
        model = get_user_model()
        fields = ('email', 'first_name', 'last_name')
```

이 페이지에서 비밀번호는 수정 안됨

암호화 과정 거쳐야 해서

비밀번호를 변경하는 폼이 따로 되어 있음

###### User model 상속 구조 살펴보기 

1. UserChangeForm 클래스 구조 확인

   Meta 클래스를 보면 User라는 model을 참조하는 ModelForm이라는 것을 확인할 수 있음 

   https://github.com/django/django/blob/main/django/contrib/auth/forms.py#L147 

2. User 클래스 구조 확인

   실제로 User 클래스는 Meta 클래스를 제외한 코드가 없고 AbstractUser 클래스를 상속 받고있음

   https://github.com/django/django/blob/main/django/contrib/auth/models.py#L405 

3. AbstractUser 클래스 구조 확인

   클래스 변수명들을 확인해보면 회원수정 페이지에서 봤던 필드들과 일치한다는 것을 확인할 수 있음. https://github.com/django/django/blob/main/django/contrib/auth/models.py#L334

4. 마지막으로 공식문서의 User 모델 Fields 확인

   https://docs.djangoproject.com/en/3.2/ref/contrib/auth/#user-model

##### 회원정보 수정 로직 작성

이제 다시 view로 가서 작성 후 실제 회원정보가 수정되었는지 확인하는 과정

```python
    if request.method == 'POST':
        form = CustomUserChangeForm(request.POST, instance=request.user)
        if form.is_valid():
            form.save()
        return redirect('articles:index')
```

추가해줌

```python
from django.shortcuts import render, redirect # redirect 추가
from django.contrib.auth.forms import AuthenticationForm # import
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
from .forms import CustomUserCreationForm, CustomUserChangeForm

def update(request):
    if request.method == 'POST':
        # 모델 폼의 첫번째 인자 - 데이터 : request.POST
        # instance 인자 있어야 수정
        form = CustomUserChangeForm(request.POST, instance=request.user)
        if form.is_valid():
            form.save()
            return redirect('articles:index')

    else: # 유저 정보는 request 객체에 있다
        form = CustomUserChangeForm(instance=request.user)
    context = {
        'form' : form,
    }
    return render(request, 'accounts/update.html', context)
```

##### 수정페이지로 가는 링크 만들기

`<a href="{% url 'accounts:update' %}">회원정보수정</a>`

base.html에 추가

`base.html`

```django
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">  <title>Document</title>
</head>
<body>
  <div class="container">
    <h3>{{ user }}</h3>
    <a href="{% url 'accounts:login' %}">Login</a>
    <form action="{% url 'accounts:logout' %}" method="POST">
      {% csrf_token %}
      <input type="submit" value="Logout">
    </form>
    <a href="{% url 'accounts:signup' %}">Signup</a>
    <form action="{% url 'accounts:delete' %}" method = 'POST'>
      {% csrf_token %}
      <input type="submit" value = "회원탈퇴">
    </form>
    <a href="{% url 'accounts:update' %}">회원정보수정</a>
    {% block content %}
    {% endblock content %}
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
</body>
</html>

```

#### 비밀번호 변경

##### PasswordChangeForm

사용자가 비밀번호를 변경할 수 있도록 하는 Form

이전 비밀번호를 입력하여 비밀번호를 변경할 수 있도록 함 

이전 비밀번호를 입력하지 않고 비밀번호를 설정할 수 있는 `SetPasswordForm`을 상속받는 서브 클래스

업데이트 어샌틱폼에서 비밀번호 수정 폼을 연결해줌

그 링크를 보면 http://127.0.0.1:8000/accounts/password/

앱 이름 accounts로 한 이유

-  장고가 내부적으로 인증 관련 활동은accounts로 쓰고 있음

##### 비밀번호 변경 페이지 작성

###### url

폼 이름대로 url은 password로

view함수는 다른 함수이름이나 식별자로 쓰일 확률이 있어서 다른 이름으로 : change_password

`  path('password/', views.change_password, name='change_password'),`

urls.py

```python
from django.urls import path
from . import views


app_name = 'accounts'
urlpatterns = [
    path('login/', views.login, name='login'),
    path('logout/', views.logout, name='logout'),
    path('signup/', views.signup, name='signup'),
    path('delete/', views.delete, name='delete'),
    path('update/', views.update, name='update'),
    path('password/', views.change_password, name='change_password'),
]


```

###### views

PasswordChangeForm import해오기

`from django.contrib.auth.forms import AuthenticationForm, `

change_password 함수 만들어주기

```python
def change_password(request):
    if request.method == "POST":
        pass
    else:
        # 인자로 user가 들어가야 함 request.user로 넣어줌
        # 지금까지와 다른 방식
        # PasswordChangeForm은 SetPasswordForm의 하위 클래스인데
        # SetPasswordForm을 확인하면 user를 인자로 받음
        form = PasswordChangeForm(request.user)
    context = {
        'form':form,
    }
    return render(request, 'accounts/change_password.html', context)
```

###### [참고] SetPasswordForm 살펴보기

PasswordChangeForm은 SetPasswordForm의 하위 클래스이기 떄문에 SetPasswordForm을 확인

```python
class SetPasswordForm(forms.Form):
    """
    A form that lets a user change set their password without entering the old
    password
    """

    error_messages = {
        "password_mismatch": _("The two password fields didn’t match."),
    }
    new_password1 = forms.CharField(
        label=_("New password"),
        widget=forms.PasswordInput(attrs={"autocomplete": "new-password"}),
        strip=False,
        help_text=password_validation.password_validators_help_text_html(),
    )
    new_password2 = forms.CharField(
        label=_("New password confirmation"),
        strip=False,
        widget=forms.PasswordInput(attrs={"autocomplete": "new-password"}),
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)
```

`accounts/views.py`

```python
from django.shortcuts import render, redirect # redirect 추가
from django.contrib.auth.forms import AuthenticationForm, PasswordChangeForm # import
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
from .forms import CustomUserCreationForm, CustomUserChangeForm



def change_password(request):
    if request.method == "POST":
        pass
    else:
        # 인자로 user가 들어가야 함 request.user로 넣어줌
        # 지금까지와 다른 방식
        # PasswordChangeForm은 SetPasswordForm의 하위 클래스인데
        # SetPasswordForm을 확인하면 user를 인자로 받음
        form = PasswordChangeForm(request.user)
    context = {
        'form':form,
    }
    return render(request, 'accounts/change_password.html', context)
```

###### templates

change_password.html

다른것이랑 똑같이

```django
{% extends 'base.html' %}

{% block content %}
<h1>비밀번호 변경</h1>
<form action="{% url 'accounts:change_password' %}" method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <input type="submit">
</form>

{% endblock content %}
```

##### 비밀번호 변경 로직 작성

views에서 POST로 받는 부분

```python
    if request.method == "POST":
        # 구조가 다름
        form = PasswordChangeForm(request.user, request.POST)
```

form 가져오고

```python
        if form.is_valid():
            form.save()
            return redirect('articles:index')
```

유효성 검사

```python
from django.shortcuts import render, redirect
from django.contrib.auth.forms import AuthenticationForm, PasswordChangeForm
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
from .forms import CustomUserCreationForm, CustomUserChangeForm

...

def change_password(request):
    if request.method == "POST":
        form = PasswordChangeForm(request.user, request.POST)
        if form.is_valid():
            form.save()
            return redirect('articles:index')
    else:
        form = PasswordChangeForm(request.user)
    context = {
        'form':form,
    }
    return render(request, 'accounts/change_password.html', context)
```

비밀번호 바꾸면 로그아웃 되는 것이 정상

##### 암호 변경 시 세션 무효화 방지하기

비밀번호 바꾸는 암호화 과정에서 이에 맞춰 새로운 새션을 만듬

비밀번호가 변경되면 기존 세션과의 회원 인증 정보가 일치하지 않게 되어 버려 로그인 상태가 유지되지 못함

비밀번호는 잘 변경되었으나 비밀번호가 변경 되면서 기존 세션과의 회원 인증 정보가 일치하지 않기 때문

기존 세션을 지금 세션으로 업데이트 해주는 과정 필요

###### update_session_auth_hash()

`update_session_auth_hash(request, user) `

현재 요청(current request)과 새 session data가 파생 될 업데이트 된 사용자 객체를 가져오고, session data를 적절하게 업데이트해줌

기존의 세션을 업데이트

암호가 변경되어도 로그아웃 되지 않도록 새로운 password의 session data로 session을 업데이트

###### update_session_auth_hash() 작성

import 해줘야 함

`from django.contrib.auth import update_session_auth_hash`

비밀번호가 변경된 직후에 함수 사용 : form.save() 다음줄

두번째 인자 `form.user'

`update_session_auth_hash(request, form.user)`

user = form.save()하고 두번째 인자로 user 넣어도 되지만 공식문서에 form.user를 넣으라고 함

```python
def change_password(request):
    if request.method == "POST":
        form = PasswordChangeForm(request.user, request.POST)
        if form.is_valid():
            form.save()
            # 두번째 인자 값이 또 다름
            # user = form.save()하고 user 넣어도 됨
            # 근데 공식문서에 form.user라고 되어있음
            update_session_auth_hash(request, form.user)
            return redirect('articles:index')
    else:
        form = PasswordChangeForm(request.user)
    context = {
        'form':form,
    }
    return render(request, 'accounts/change_password.html', context)
```

이제 출력 확인해보면 비밀번호 바뀌어도 로그아웃 안됨

개발자도구 애플리케이션에서 세션을 봐도 세션정보가 그대로

### Limiting access to logged-in users

로그인한 유저의 권한에 맞춰서 분리처리를 해야 함 (다른게 보이게)

그에 따라 로직을 다듬어야 함

로그인 사용자에 대한 접근 제한하기 

로그인 사용자에 대해 접근을 제한하는 2가지 방법 

1. The raw way 

   - 속성으로 하는 방법
   - `is_authenticated` attribute 
   - True, False값

2. The `login_required` decorator

   - 데코레이터로 하는 방법

   - 로그인이 필요한 조건을 검

#### is_authenticated 

User model의 속성(attributes) 중 하나

사용자가 인증 되었는지 여부를 알 수 있는 방법

모든 User 인스턴스에 대해 항상 True인 읽기 전용 속성

- True면 User 인스턴스 == 인증된 유저 

- AnonymousUser에 대해서는 항상 False
- 고정된 속성값, 바뀌지 않음

일반적으로 `request.use`r에서 이 속성을 사용 (`request.user.is_authenticated`) 

주의사항

- 권한(permission)과는 관련이 없으며, 사용자가 활성화 상태(active)이 유효한 세션(valid session)을 가지고 있는지도 확인하지 않음
- 로그인 사용자나 비로그인 사용자냐만 딱 봄

##### 공식문서 코드

https://github.com/django/django/blob/main/django/contrib/auth/base_user.py#L56

```python
class AbstractBaseUser(models.Model):
	...
    @property
    def is_authenticated(self):
        """
        Always return True. This is a way to tell if the user has been
        authenticated in templates.
        """
        return True
    # AbstractBaseUser : Abstract를 베이스로 만들어진 유저라면
    # Always return True
```

##### 적용하기

###### 로그인했을때와 안했을 때를 나눠줌

base.html 수정

```django
    {% if request.user.is_authenticated %}
    {% else %}
    {% endif %}
```

- request이용할 수 있는 이유
  - settins.py에 context_processors에 있음

###### 각각 보여줘야할 것 따로

인증된 사용자만 게시글 작성 링크를 볼 수 있도록 처리하기

로그인했을 때 보여야 할 것

- 유저 텍스트 {{ user }}

- 로그아웃버튼

- 회원탈퇴버튼

- 회원정보수정 페이지 링크

로그아웃했을 때 보여야 할것

- 로그인 페이지 링크

- 회원가입 페이지 링크

각 위치에 이동 

`base.html`

```django
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">  <title>Document</title>
</head>
<body>
  <div class="container">
    {% if request.user.is_authenticated %}
    <h3>{{ user }}</h3>
    <form action="{% url 'accounts:logout' %}" method="POST">
      {% csrf_token %}
      <input type="submit" value="Logout">
    </form>
    <form action="{% url 'accounts:delete' %}" method = 'POST'>
      {% csrf_token %}
      <input type="submit" value = "회원탈퇴">
    </form>
    <a href="{% url 'accounts:update' %}">회원정보수정</a>
    {% else %}
    <a href="{% url 'accounts:login' %}">Login</a>
    <a href="{% url 'accounts:signup' %}">Signup</a>
    {% endif %}
    <hr>
    {% block content %}
    {% endblock content %}
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
</body>
</html>

```

###### 문제점

근본적으로 막은게 아니라서 URL을 직접 입력하면 로그인 페이지로 들어갈 수 있음

###### 인증된 사용자라면 로그인 로직을 수행할 수 없도록 처리

views 함수에서 먼저 막아줌

로그인 함수 상단에

```py
    if request.user.is_authenticated:
        return redirect('articles:index')
```

추가

```python
from django.shortcuts import render, redirect # redirect 추가
from django.contrib.auth.forms import AuthenticationForm, PasswordChangeForm # import
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
from django.contrib.auth import update_session_auth_hash
from .forms import CustomUserCreationForm, CustomUserChangeForm

# Create your views here.
def login(request):
    # 로그인 했으면 그냥 함수 끝내버림
    if request.user.is_authenticated:
        return redirect('articles:index')
    if request.method == 'POST':
        form = AuthenticationForm(request, request.POST)
        if form.is_valid():
            auth_login(request, form.get_user()) 
            return redirect('articles:index')
    else:
        form = AuthenticationForm()
    context = {
        'form' : form,
    }
    return render(request, 'accounts/login.html', context)

...
```

그러면 주소에 넣어주도 다시 index로 돌아감

###### Create 버튼도 로그인 사용자만 보게

```django
  {% if request.user.is_authenticated %}
  <a href="{% url 'articles:create' %}">CREATE</a>
  {% endif %}
```



`base.html`

```django
{% extends 'base.html' %}

{% block content %}
  <h1>Articles</h1>
  {% if request.user.is_authenticated %}
  <a href="{% url 'articles:create' %}">CREATE</a>
  {% endif %}
  <hr>
  {% for article in articles %}
    <p>글 번호 : {{ article.pk }}</p>
    <p>제목 : {{ article.title }}</p>
    <p>내용 : {{ article.content }}</p>
    <a href="{% url 'articles:detail' article.pk %}">상세 페이지</a>
    <hr>
  {% endfor %}
{% endblock content %}
```

#### login_required

login_required decorator

사용자가 로그인 되어 있으면 정상적으로 view 함수를 실행

로그인 하지 않은 사용자의 경우 settings.py의 LOGIN_URL 문자열 주소로 redirect

- [참고] LOGIN_URL의 기본 값은 /accounts/login/ 
- 두번째 app 이름을 accounts 로 했던 이유 중 하나

로그인된 사용자만 DB를 권한할 수 있는 권한을 줌

##### 적용하기

###### 로그인 상태에서만 글을 작성/수정/삭제할 수 있도록 변경

views함수에 데코레이터 추가

articles/views.py

위에

````python
from django.contrib.auth.decorators import login_required
````

추가

데코레이터 생성, 수정, 삭제위에 넣어줌

```python
@login_required
```

각각 추가

```python
from django.shortcuts import render, redirect
from django.views.decorators.http import require_http_methods, require_POST, require_safe
from django.contrib.auth.decorators import login_required # 추가
from .models import Article
from .forms import ArticleForm


# Create your views here.
@require_safe
def index(request):
    articles = Article.objects.all()
    context = {
        'articles': articles,
    }
    return render(request, 'articles/index.html', context)


@login_required # 추가
@require_http_methods(['GET', 'POST'])
def create(request):
    if request.method == 'POST':
        form = ArticleForm(request.POST)
        if form.is_valid():
            article = form.save()
            return redirect('articles:detail', article.pk)
    else:
        form = ArticleForm()
    context = {
        'form': form,
    }
    return render(request, 'articles/create.html', context)


@require_safe
def detail(request, pk):
    article = Article.objects.get(pk=pk)
    context = {
        'article': article,
    }
    return render(request, 'articles/detail.html', context)


@login_required # 추가
@require_POST
def delete(request, pk):
    article = Article.objects.get(pk=pk)
    article.delete()
    return redirect('articles:index')


@login_required # 추가
@require_http_methods(['GET', 'POST'])
def update(request, pk):
    article = Article.objects.get(pk=pk)
    if request.method == 'POST':
        form = ArticleForm(request.POST, instance=article)
        # form = ArticleForm(data=request.POST, instance=article)
        if form.is_valid():
            form.save()
            return redirect('articles:detail', article.pk)
    else:
        form = ArticleForm(instance=article)
    context = {
        'form': form,
        'article': article,
    }
    return render(request, 'articles/update.html', context)

```

비로그인 상태에서 생성 수정 삭제를 하면 로그인창으로 감

##### login_required 적용 확인하기

/articles/create/ 로 강제 접속 시도 해보기

로그인 페이지로 리다이렉트 후 `/accounts/login/?next=/articles/create/` url 확인하기

인증 성공 시 사용자가 redirect 되어야하는 경로는 "next"라는 쿼리 문자열 매개 변수에 저장됨 

• 예) /accounts/login/`?next=/articles/create/`

의문

- django는 어떻게 우리 로그인창 주소를 알았을까(accounts/login.html)
- 주소를 보면 `?next=`가 있음 
  - 넥스트 파라미터
  - http://127.0.0.1:8000/accounts/login/?next=/articles/create/

답

- 우리 주소 모름
  - `/accounts/login/`으로 보내도록 내부적으로 되어있음
  - 이것도 accounts로 이름 설정하는 이유
  - 우리가 저 주소로 안했으면 낫파운드 뜸
- 넥스트 파라미터 뒤에 직전에 요청했던 주소
  - 로그인에 성공하면 쓰라고 뒤에 남겨줌
  - 가게 하려면 `login.html` action을 비워둠
    - `<form action="" method="POST">`
  - 그러면 브라우저 주소창에 있는 url로 이동
  - 주소 형식에서 key : `next`, value: `/articles/create/`
    - 예전에 GET방식 받을 때 /?title=aaa&content=aaa/
    - 이건 request.GET을 딕셔너리로 받은것
    - 그래서 title=request.GET.get('title') 이렇게 뻼
    - 그러면 aaa 나옴
  - 즉 result = request.GET.get('next') 하면 /articles/create/ 값이 나옴

##### "next" query string parameter

로그인이 정상적으로 진행되면 이전에 요청했던 주소로 redirect 하기 위해 Django가 제공해주는 쿼리 스트링 파라미터

해당 값을 처리할지 말지는 자유이며 별도로 처리 해주지 않으면 view에 설정한 redirect 경로로 이동하게 됨

##### "next" query string parameter 대응

###### 파라미터로 로그인창 갔다가 바로 원래 가려했던 곳 가기

accounts/views 수정

login함수에 유효성 검사 통과한 곳에

```python
return redirect(request.GET.get('next') or 'articles:index')
```

단축평가

앞에가 트루면 or 뒤에 볼 필요 없음

앞에가 false면 뒤에가 들어감

파이써닉

accounts/views.py

```python
from django.shortcuts import render, redirect # redirect 추가
from django.contrib.auth.forms import AuthenticationForm, PasswordChangeForm # import
from django.contrib.auth import login as auth_login
from django.contrib.auth import logout as auth_logout
from django.contrib.auth import update_session_auth_hash
from .forms import CustomUserCreationForm, CustomUserChangeForm

# Create your views here.
def login(request):
    if request.user.is_authenticated:
        return redirect('articles:index')
    if request.method == 'POST':
        form = AuthenticationForm(request, request.POST)
        if form.is_valid():
            auth_login(request, form.get_user())
                             # 단축 평가
            return redirect(request.GET.get('next') or 'articles:index')
    else:
        form = AuthenticationForm()
    context = {
        'form' : form,
    }
    return render(request, 'accounts/login.html', context)

...
```

request.GET.get('next')가 있으면 그 값으로 이동함 지금은 (/articles/create/)

즉 저 주소인 로그인창에서 로그인을 하면 index로 안가고 create창으로 감

##### "next" query string parameter 주의사항

만약 login 템플릿에서 form action이 작성되어 있다면 동작하지 않음

해당 action 주소 next파라미터가 작성되어있는 현재 url이 아닌 /accounts/login/으로 요청을 보냄

비우면 현재 브라우저 창의 주소로 이동

###### login창 폼의 action 비워주기

```python
<form action="" method="POST">
```

login.html

```django
{% extends 'base.html' %}

{% block content %}
<h1>LOGIN</h1>
<form action="" method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <input type="submit">
</form>

{% endblock content %}
```

##### 두 데코레이터로 인해 발생하는 구조적 문제 

1. 먼저 비로그인 상태로 detail 페이지에서 게시글 삭제 시도 
2. delete view 함수의 `@login_required`로 인해 로그인 페이지로 리다이렉트
   - http://127.0.0.1:8000/accounts/login/?next=/articles/1/delete/
3. redirect로 이동한 로그인 페이지에서 로그인 진행
4. delete view 함수의 `@require_POST`로 인해 405 상태 코드를 받게 됨 
   - 405(Method Not Allowed) status code 확인
   - login 성공하고 next파라미터로 redirect하는건 GET방식
   - 리다이렉트는 POST가 안됨

##### 문제 해결

POST method만 허용하는 delete 같은 함수는 내부에서는

is_authenticated 속성 값을 사용해서 처리

인증을 안에서 처리

articles/views.py

`@login_required` 삭제

```python
    if request.user.is_authenticated:
        article = Article.objects.get(pk=pk)
        article.delete()
```

if로 속성값 조건 달아줌

그러면 POST를 먼저 확인하고 그 다음 인증 여부 확인

`articles/views.py`

```python
from django.shortcuts import render, redirect
from django.views.decorators.http import require_http_methods, require_POST, require_safe
from django.contrib.auth.decorators import login_required
from .models import Article
from .forms import ArticleForm

...

# 이렇게 하면 POST를 먼저 확인하고 인증 확인 가능
@require_POST
def delete(request, pk):
    if request.user.is_authenticated:
        article = Article.objects.get(pk=pk)
        article.delete()
    return redirect('articles:index')

...
```

삭제 말고 생성, 수정은 괜찮음 GET에 대한 처리도 있기 때문에

하지만 삭제는 GET처리가 없어서 로직이 이상해짐 그래서 한쪽을 포기하고 안에 넣어줌

#### accounts view함수에 데코레이터 및 속성값 적용해보기

```python
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import required_POST, required_http_methods
```

두개 추가해서 불러와주기

##### login view 함수

```python
@require_http_methods(['GET', 'POST'])
```

추가

```python
@require_http_methods(['GET', 'POST'])
def login(request):
    if request.user.is_authenticated:
        return redirect('articles:index')
    if request.method == 'POST':
        form = AuthenticationForm(request, request.POST) 
        if form.is_valid():
            auth_login(request, form.get_user())
            return redirect(request.GET.get('next') or 'articles:index')
    else:
        form = AuthenticationForm()
    context = {
        'form' : form,
    }
    return render(request, 'accounts/login.html', context)
```



##### logout view 함수

```python
@require_POST
```

데코레이터 추가

```python
    if request.user.is_authenticated:
```

데코레이터 대신 속성값 추가

```python
    if request.user.is_authenticated:
        auth_logout(request) 
```

if 문 안에 넣어주기

```python
@require_POST
def logout(request):
    # 로그아웃
    if request.user.is_authenticated:
        auth_logout(request)
    return redirect('articles:index')
```

##### signup view 함수

```python
@require_http_methods(['GET', 'POST'])
```

추가

```python
@require_http_methods(['GET', 'POST'])
def signup(request):
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            auth_login(request, user)
            return redirect('articles:index')
    else:
        form = CustomUserCreationForm()
    context = {
        'form':form,
    }
    return render(request, 'accounts/signup.html', context)
```



##### update view 함수

```python
@login_required
@require_http_methods(['GET', 'POST'])
```

추가

```python
@login_required
@require_http_methods(['GET', 'POST'])
def update(request):
    if request.method == 'POST':
        # 모델 폼의 첫번째 인자 - 데이터 : request.POST
        # instance 인자 있어야 수정
        form = CustomUserChangeForm(request.POST, instance=request.user)
        if form.is_valid():
            form.save()
        return redirect('articles:index')

    else: # 유저 정보는 request 객체에 있다
        form = CustomUserChangeForm(instance=request.user)
    context = {
        'form' : form,
    }
    return render(request, 'accounts/update.html', context)
```



##### change_password 함수

```python
@login_required
@require_http_methods(['GET', 'POST'])
```

추가

```python
@login_required
@require_http_methods(['GET', 'POST'])
def change_password(request):
    if request.method == "POST":
        form = PasswordChangeForm(request.user, request.POST)
        if form.is_valid():
            form.save()
            update_session_auth_hash(request, form.user)
            return redirect('articles:index')
    else:
        form = PasswordChangeForm(request.user)
    context = {
        'form':form,
    }
    return render(request, 'accounts/change_password.html', context)
```

